/* Generated By:JavaCC: Do not edit this line. MitabLineParser.java */
package psidev.psi.mi.jami.tab.io.parser;

import psidev.psi.mi.jami.model.*;
import psidev.psi.mi.jami.datasource.DefaultFileSourceContext;
import psidev.psi.mi.jami.tab.extension.*;
import psidev.psi.mi.jami.tab.listener.MitabParserListener;
import java.util.Collection;
import java.util.Collections;
import psidev.psi.mi.jami.utils.CvTermUtils;
import psidev.psi.mi.jami.utils.PositionUtils;
import java.util.ArrayList;
import java.util.EnumSet;
import java.lang.NumberFormatException;
import psidev.psi.mi.jami.exception.IllegalParameterException;
import psidev.psi.mi.jami.exception.IllegalRangeException;
import psidev.psi.mi.jami.tab.utils.MitabUtils;

public abstract class MitabLineParser<T extends Interaction, P extends Participant, F extends Feature> implements MitabLineParserConstants {

        void processSyntaxError(int lineNumber, int columnNumber, int mitabColumn, Exception e) {
            fireOnInvalidSyntax(lineNumber, columnNumber, mitabColumn, e);
        }

        public abstract MitabParserListener getParserListener();

        public abstract void setParserListener(MitabParserListener listener);

    abstract void fireOnInvalidSyntax(int lineNumber, int columnNumber, int mitabColumn, Exception e);

    abstract void reachEndOfFile();

    public abstract boolean hasFinished();

    abstract java.lang.StringBuilder resetStringBuilder();

    abstract F createFeature(String type, Collection<Range> ranges, String text, int line, int column, int mitabColumn);

        abstract P finishParticipant(Collection<MitabXref> uniqueId, Collection<MitabXref> altid , Collection<MitabAlias> aliases,
                                               Collection<MitabOrganism> taxid, Collection<MitabCvTerm> bioRole, Collection<MitabCvTerm> expRole,
                                               Collection<MitabCvTerm> type, Collection<MitabXref> xref, Collection<MitabAnnotation> annot,
                                               Collection<MitabChecksum> checksum, Collection<F> feature, Collection<MitabStoichiometry> stc,
                                               Collection<MitabCvTerm> detMethod, int line, int column, int mitabColumn);
        abstract T finishInteraction(P A, P B, Collection<MitabCvTerm> detMethod, Collection<MitabAuthor> firstAuthor,
                                               Collection<MitabXref> pubId, Collection<MitabCvTerm> interactionType, Collection<MitabSource> source,
                                               Collection<MitabXref> interactionId, Collection<MitabConfidence> conf, Collection<MitabCvTerm> expansion,
                                               Collection<MitabXref> xrefI, Collection<MitabAnnotation> annotI, Collection<MitabOrganism> host,
                                               Collection<MitabParameter> params, Collection<MitabDate> created, Collection<MitabDate> update,
                                               Collection<MitabChecksum> checksumI, boolean isNegative, int line);

  final public T MitabLine() throws ParseException {
  Collection<MitabXref> uniqueIdA = Collections.EMPTY_LIST;
  Collection<MitabXref> uniqueIdB = Collections.EMPTY_LIST;
  Collection<MitabXref> altIdA = Collections.EMPTY_LIST;
  Collection<MitabXref> altIdB = Collections.EMPTY_LIST;
  Collection<MitabAlias> aliasA = Collections.EMPTY_LIST;
  Collection<MitabAlias> aliasB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> detMethod = Collections.EMPTY_LIST;
  Collection<MitabAuthor> firstAuthor = Collections.EMPTY_LIST;
  Collection<MitabXref> pubId = Collections.EMPTY_LIST;
  Collection<MitabOrganism> taxidA = Collections.EMPTY_LIST;
  Collection<MitabOrganism> taxidB= Collections.EMPTY_LIST;
  Collection<MitabCvTerm> interactionType = Collections.EMPTY_LIST;
  Collection<MitabSource> source = Collections.EMPTY_LIST;
  Collection<MitabXref> interactionId = Collections.EMPTY_LIST;
  Collection<MitabConfidence> conf = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> expansion = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> bioRoleA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> bioRoleB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> expRoleA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> expRoleB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> typeA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> typeB = Collections.EMPTY_LIST;
  Collection<MitabXref> xrefA = Collections.EMPTY_LIST;
  Collection<MitabXref> xrefB = Collections.EMPTY_LIST;
  Collection<MitabXref> xrefI = Collections.EMPTY_LIST;
  Collection<MitabAnnotation> annotA = Collections.EMPTY_LIST;
  Collection<MitabAnnotation> annotB = Collections.EMPTY_LIST;
  Collection<MitabAnnotation> annotI = Collections.EMPTY_LIST;
  Collection<MitabOrganism> host = Collections.EMPTY_LIST;
  Collection<MitabParameter> params = Collections.EMPTY_LIST;
  Collection<MitabDate> created = Collections.EMPTY_LIST;
  Collection<MitabDate> update = Collections.EMPTY_LIST;
  Collection<MitabChecksum> checksumA = Collections.EMPTY_LIST;
  Collection<MitabChecksum> checksumB = Collections.EMPTY_LIST;
  Collection<MitabChecksum> checksumI = Collections.EMPTY_LIST;
  boolean isNegative = false;
  Collection<F> featureA = Collections.EMPTY_LIST;
  Collection<F> featureB = Collections.EMPTY_LIST;
  Collection<MitabStoichiometry> stcA = Collections.EMPTY_LIST;
  Collection<MitabStoichiometry> stcB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> pmethodA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> pmethodB = Collections.EMPTY_LIST;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR);
  EnumSet<TokenKind> columnSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);

  P participantA=null;
  P participantB=null;
  T interaction=null;
  int line;
  int columnA;
  int columnB;
  CvTerm identity = CvTermUtils.createIdentityQualifier();
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LINE_SEPARATOR:
        jj_consume_token(LINE_SEPARATOR);
        break;
      case 0:
        jj_consume_token(0);
           reachEndOfFile();
        break;
      case COMMENT:
        jj_consume_token(COMMENT);
        anyStringBut(enumSet);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LINE_SEPARATOR:
          jj_consume_token(LINE_SEPARATOR);
          break;
        case 0:
          jj_consume_token(0);
                                                                reachEndOfFile();
          break;
        default:
          jj_la1[0] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[43] = jj_gen;
        try {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                     uniqueIdA = Collections.EMPTY_LIST; line = token.beginLine; columnA = token.beginColumn;
            break;
          default:
            jj_la1[1] = jj_gen;
            uniqueIdA = ids(identity, false, 1);
          }
                                                                                                                                                       line = token.beginLine; columnA = token.beginColumn;
          jj_consume_token(COLUMN_SEPARATOR);
        } catch (ParseException e) {
          line = token.beginLine; columnA = token.beginColumn;
          processSyntaxError(token.beginLine, token.beginColumn, 1, e);
          error_skipToNext(columnSet, true);
        }
        try {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                     uniqueIdB = Collections.EMPTY_LIST; columnB = token.beginColumn;
            break;
          default:
            jj_la1[2] = jj_gen;
            uniqueIdB = ids(identity, false, 2);
          }
                                                                                                                               columnB = token.beginColumn;
          jj_consume_token(COLUMN_SEPARATOR);
        } catch (ParseException e) {
            columnB = token.beginColumn;
            processSyntaxError(token.beginLine, token.beginColumn, 2, e);
             error_skipToNext(columnSet, true);
        }
        try {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                     altIdA = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[3] = jj_gen;
            altIdA = ids(CvTermUtils.getSecondary(), false, 3);
          }
          jj_consume_token(COLUMN_SEPARATOR);
        } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 3, e);
                  error_skipToNext(columnSet, true);
        }
        try {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                     altIdB = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[4] = jj_gen;
            altIdB = ids(CvTermUtils.getSecondary(), false, 4);
          }
          jj_consume_token(COLUMN_SEPARATOR);
        } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 4, e);
                  error_skipToNext(columnSet, true);
        }
        try {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                     aliasA = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[5] = jj_gen;
            aliasA = aliases(5);
          }
          jj_consume_token(COLUMN_SEPARATOR);
        } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 5, e);
                  error_skipToNext(columnSet, true);
        }
        try {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                     aliasB = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[6] = jj_gen;
            aliasB = aliases(6);
          }
          jj_consume_token(COLUMN_SEPARATOR);
        } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 6, e);
                  error_skipToNext(columnSet, true);
        }
        try {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                     detMethod = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[7] = jj_gen;
            detMethod = cvTerms(7);
          }
          jj_consume_token(COLUMN_SEPARATOR);
        } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 7, e);
                  error_skipToNext(columnSet, true);
        }
        try {
          if (jj_2_1(2)) {
            jj_consume_token(DASH);
                                  firstAuthor = Collections.EMPTY_LIST;
            jj_consume_token(COLUMN_SEPARATOR);
          } else {
            firstAuthor = firstAuthors();
            jj_consume_token(COLUMN_SEPARATOR);
          }
        } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 8, e);
                  error_skipToNext(columnSet, true);
        }
        try {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                     pubId = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[8] = jj_gen;
            pubId = ids(identity, true, 9);
          }
          jj_consume_token(COLUMN_SEPARATOR);
        } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 9, e);
                  error_skipToNext(columnSet, true);
        }
        try {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                     taxidA = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[9] = jj_gen;
            taxidA = taxId(10);
          }
          jj_consume_token(COLUMN_SEPARATOR);
        } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 10, e);
                  error_skipToNext(columnSet, true);
        }
        try {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                     taxidB = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[10] = jj_gen;
            taxidB = taxId(11);
          }
          jj_consume_token(COLUMN_SEPARATOR);
        } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 11, e);
                  error_skipToNext(columnSet, true);
        }
        try {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                     interactionType = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[11] = jj_gen;
            interactionType = cvTerms(12);
          }
          jj_consume_token(COLUMN_SEPARATOR);
        } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 12, e);
                  error_skipToNext(columnSet, true);
        }
        try {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                     source = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[12] = jj_gen;
            source = sourceDbs();
          }
          jj_consume_token(COLUMN_SEPARATOR);
        } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 13, e);
                  error_skipToNext(columnSet, true);
        }
        try {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                     interactionId = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[13] = jj_gen;
            interactionId = ids(identity, true, 14);
          }
          jj_consume_token(COLUMN_SEPARATOR);
        } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 14, e);
                  error_skipToNext(columnSet, true);
        }
        try {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                     conf = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[14] = jj_gen;
            conf = confidences();
          }
        } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 15, e);
                  error_skipToNext(columnSet, true);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COLUMN_SEPARATOR:
          jj_consume_token(COLUMN_SEPARATOR);
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     expansion = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[15] = jj_gen;
              expansion = complexExpansion();
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 16, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     bioRoleA = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[16] = jj_gen;
              bioRoleA = cvTerms(17);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 17, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     bioRoleB = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[17] = jj_gen;
              bioRoleB = cvTerms(18);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 18, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     expRoleA = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[18] = jj_gen;
              expRoleA = cvTerms(19);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 19, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     expRoleB = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[19] = jj_gen;
              expRoleB = cvTerms(20);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 20, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     typeA = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[20] = jj_gen;
              typeA = cvTerms(21);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 21, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     typeB = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[21] = jj_gen;
              typeB = cvTerms(22);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 22, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     xrefA = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[22] = jj_gen;
              xrefA = ids(null, false, 23);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 23, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     xrefB = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[23] = jj_gen;
              xrefB = ids(null, false, 24);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 24, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     xrefI = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[24] = jj_gen;
              xrefI = ids(null, false, 25);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 25, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     annotA = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[25] = jj_gen;
              annotA = annotations(26);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 26, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     annotB = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[26] = jj_gen;
              annotB = annotations(27);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 27, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     annotI = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[27] = jj_gen;
              annotI = annotations(28);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 28, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     host = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[28] = jj_gen;
              host = taxId(29);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 29, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     params = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[29] = jj_gen;
              params = parameters();
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 30, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     created = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[30] = jj_gen;
              created = dates(31);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 31, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     update = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[31] = jj_gen;
              update = dates(32);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 32, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     checksumA = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[32] = jj_gen;
              checksumA = checksums(33);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 33, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     checksumB = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[33] = jj_gen;
              checksumB = checksums(34);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 34, e);
                  error_skipToNext(columnSet, true);
          }
          try {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                     checksumI = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[34] = jj_gen;
              checksumI = checksums(35);
            }
            jj_consume_token(COLUMN_SEPARATOR);
          } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 35, e);
                  error_skipToNext(columnSet, true);
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
            break;
          default:
            jj_la1[35] = jj_gen;
            isNegative = negative();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COLUMN_SEPARATOR:
            jj_consume_token(COLUMN_SEPARATOR);
            try {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case DASH:
                jj_consume_token(DASH);
                     featureA = Collections.EMPTY_LIST;
                break;
              default:
                jj_la1[36] = jj_gen;
                featureA = features(37);
              }
              jj_consume_token(COLUMN_SEPARATOR);
            } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 37, e);
                  error_skipToNext(columnSet, true);
            }
            try {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case DASH:
                jj_consume_token(DASH);
                     featureB = Collections.EMPTY_LIST;
                break;
              default:
                jj_la1[37] = jj_gen;
                featureB = features(38);
              }
              jj_consume_token(COLUMN_SEPARATOR);
            } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 38, e);
                  error_skipToNext(columnSet, true);
            }
            try {
              if (jj_2_2(2)) {
                jj_consume_token(DASH);
                                  stcA = Collections.EMPTY_LIST;
                jj_consume_token(COLUMN_SEPARATOR);
              } else {
                stcA = stoichiometryList(39);
                jj_consume_token(COLUMN_SEPARATOR);
              }
            } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 39, e);
                  error_skipToNext(columnSet, true);
            }
            try {
              if (jj_2_3(2)) {
                jj_consume_token(DASH);
                                  stcB = Collections.EMPTY_LIST;
                jj_consume_token(COLUMN_SEPARATOR);
              } else {
                stcB = stoichiometryList(40);
                jj_consume_token(COLUMN_SEPARATOR);
              }
            } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 40, e);
                  error_skipToNext(columnSet, true);
            }
            try {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case DASH:
                jj_consume_token(DASH);
                     pmethodA = Collections.EMPTY_LIST;
                break;
              default:
                jj_la1[38] = jj_gen;
                pmethodA = cvTerms(41);
              }
              jj_consume_token(COLUMN_SEPARATOR);
            } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 41, e);
                  error_skipToNext(columnSet, true);
            }
            try {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case DASH:
                jj_consume_token(DASH);
                     pmethodB = Collections.EMPTY_LIST;
                break;
              default:
                jj_la1[39] = jj_gen;
                pmethodB = cvTerms(42);
              }
            } catch (ParseException e) {
                  processSyntaxError(token.beginLine, token.beginColumn, 42, e);
                  error_skipToNext(columnSet, true);
            }
            break;
          default:
            jj_la1[40] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[41] = jj_gen;
          ;
        }
                participantA = finishParticipant(uniqueIdA, altIdA, aliasA, taxidA, bioRoleA, expRoleA, typeA, xrefA, annotA, checksumA, featureA, stcA, pmethodA, line, columnA, 1);
                participantB = finishParticipant(uniqueIdB, altIdB, aliasB, taxidB, bioRoleB, expRoleB, typeB, xrefB, annotB, checksumB, featureB, stcB, pmethodB, line, columnB, 2);
                interaction = finishInteraction(participantA, participantB, detMethod, firstAuthor, pubId, interactionType, source, interactionId,
                                         conf, expansion, xrefI, annotI, host, params, created, update, checksumI, isNegative, line);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LINE_SEPARATOR:
          jj_consume_token(LINE_SEPARATOR);
          break;
        case 0:
          jj_consume_token(0);
                                 reachEndOfFile();
          break;
        default:
          jj_la1[42] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
       {if (true) return interaction;}
    } catch (ParseException e) {
        processSyntaxError(token.beginLine, token.beginColumn, 0, e);
        error_skipToNext(enumSet, true);
        {if (true) return interaction;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabXref> ids(CvTerm qualifier, boolean recognizeImex, int column) throws ParseException {
  Collection<MitabXref> xrefs;
  MitabXref var;
    var = id(qualifier, recognizeImex, column);
    xrefs = new ArrayList<MitabXref>(); if (var != null) {xrefs.add(var);}
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIELD_SEPARATOR:
        ;
        break;
      default:
        jj_la1[44] = jj_gen;
        break label_1;
      }
      jj_consume_token(FIELD_SEPARATOR);
      var = id(qualifier, recognizeImex, column);
                                                                  if (var != null) {xrefs.add(var);}
    }
    {if (true) return xrefs;}
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabAlias> aliases(int column) throws ParseException {
  Collection<MitabAlias> aliases;
  MitabAlias var;
    var = alias(column);
     aliases = new ArrayList<MitabAlias>(); if (var != null) {if (var != null) {aliases.add(var);}}
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIELD_SEPARATOR:
        ;
        break;
      default:
        jj_la1[45] = jj_gen;
        break label_2;
      }
      jj_consume_token(FIELD_SEPARATOR);
      var = alias(column);
                                            if (var != null) {if (var != null) {aliases.add(var);}}
    }
     {if (true) return aliases;}
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabCvTerm> cvTerms(int columnNumber) throws ParseException {
  Collection<MitabCvTerm> methods;
  MitabCvTerm var;
    var = cvTerm(columnNumber);
     methods = new ArrayList<MitabCvTerm>(); if (var != null) {methods.add(var);}
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIELD_SEPARATOR:
        ;
        break;
      default:
        jj_la1[46] = jj_gen;
        break label_3;
      }
      jj_consume_token(FIELD_SEPARATOR);
      var = cvTerm(columnNumber);
                                                   if (var != null) {methods.add(var);}
    }
     {if (true) return methods;}
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabAuthor> firstAuthors() throws ParseException {
  Collection<MitabAuthor> authors;
  MitabAuthor var;
    var = author();
     authors = new ArrayList<MitabAuthor>(); if (var != null) {authors.add(var);}
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIELD_SEPARATOR:
        ;
        break;
      default:
        jj_la1[47] = jj_gen;
        break label_4;
      }
      jj_consume_token(FIELD_SEPARATOR);
      var = author();
                                       if (var != null) {authors.add(var);}
    }
     {if (true) return authors;}
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabOrganism> taxId(int column) throws ParseException {
  Collection<MitabOrganism> organisms;
  MitabOrganism var;
    var = organism(column);
     organisms = new ArrayList<MitabOrganism>(); if (var != null) {organisms.add(var);}
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIELD_SEPARATOR:
        ;
        break;
      default:
        jj_la1[48] = jj_gen;
        break label_5;
      }
      jj_consume_token(FIELD_SEPARATOR);
      var = organism(column);
                                               if (var != null) {organisms.add(var);}
    }
     {if (true) return organisms;}
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabSource> sourceDbs() throws ParseException {
  Collection<MitabSource> sources;
  MitabSource var;
    var = source();
     sources = new ArrayList<MitabSource>(); if (var != null) {sources.add(var);}
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIELD_SEPARATOR:
        ;
        break;
      default:
        jj_la1[49] = jj_gen;
        break label_6;
      }
      jj_consume_token(FIELD_SEPARATOR);
      var = source();
                                       if (var != null) {sources.add(var);}
    }
     {if (true) return sources;}
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabConfidence> confidences() throws ParseException {
  Collection<MitabConfidence> confs;
  MitabConfidence var;
    var = confidence();
     confs = new ArrayList<MitabConfidence>(); if (var != null) {confs.add(var);}
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIELD_SEPARATOR:
        ;
        break;
      default:
        jj_la1[50] = jj_gen;
        break label_7;
      }
      jj_consume_token(FIELD_SEPARATOR);
      var = confidence();
                                           if (var != null) {confs.add(var);}
    }
     {if (true) return confs;}
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabCvTerm> complexExpansion() throws ParseException {
  Collection<MitabCvTerm> expansions;
  MitabCvTerm var;
    var = expansion();
     expansions = new ArrayList<MitabCvTerm>(); if (var != null) {expansions.add(var);}
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIELD_SEPARATOR:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_8;
      }
      jj_consume_token(FIELD_SEPARATOR);
      var = expansion();
                                          if (var != null) {expansions.add(var);}
    }
     {if (true) return expansions;}
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabAnnotation> annotations(int column) throws ParseException {
  Collection<MitabAnnotation> annots;
  MitabAnnotation var;
    var = annotation(column);
       annots = new ArrayList<MitabAnnotation>(); if (var != null) {annots.add(var);}
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIELD_SEPARATOR:
        ;
        break;
      default:
        jj_la1[52] = jj_gen;
        break label_9;
      }
      jj_consume_token(FIELD_SEPARATOR);
      var = annotation(column);
                                                   if (var != null) {annots.add(var);}
    }
       {if (true) return annots;}
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabParameter> parameters() throws ParseException {
  Collection<MitabParameter> params;
  MitabParameter var;
    var = parameter();
     params = new ArrayList<MitabParameter>(); if (var != null) {params.add(var);}
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIELD_SEPARATOR:
        ;
        break;
      default:
        jj_la1[53] = jj_gen;
        break label_10;
      }
      jj_consume_token(FIELD_SEPARATOR);
      var = parameter();
                                          if (var != null) {params.add(var);}
    }
     {if (true) return params;}
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabDate> dates(int column) throws ParseException {
  Collection<MitabDate> dates;
  MitabDate var;
    var = date(column);
       dates = new ArrayList<MitabDate>(); if (var != null) {if (var != null) {dates.add(var);}}
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIELD_SEPARATOR:
        ;
        break;
      default:
        jj_la1[54] = jj_gen;
        break label_11;
      }
      jj_consume_token(FIELD_SEPARATOR);
      var = date(column);
                                             if (var != null) {if (var != null) {if (var != null) {dates.add(var);}}}
    }
       {if (true) return dates;}
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabChecksum> checksums(int column) throws ParseException {
  Collection<MitabChecksum> checksums;
  MitabChecksum var;
    var = checksum(column);
       checksums = new ArrayList<MitabChecksum>(); if (var != null) {checksums.add(var);}
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIELD_SEPARATOR:
        ;
        break;
      default:
        jj_la1[55] = jj_gen;
        break label_12;
      }
      jj_consume_token(FIELD_SEPARATOR);
      var = checksum(column);
                                                 if (var != null) {checksums.add(var);}
    }
       {if (true) return checksums;}
    throw new Error("Missing return statement in function");
  }

  final public Collection<F> features(int column) throws ParseException {
  Collection<F> features;
  F var;
    var = feature(column);
        features = new ArrayList<F>(); if (var != null) {features.add(var);}
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIELD_SEPARATOR:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_13;
      }
      jj_consume_token(FIELD_SEPARATOR);
      var = feature(column);
                                                 if (var != null) {features.add(var);}
    }
        {if (true) return features;}
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabStoichiometry> stoichiometryList(int column) throws ParseException {
  Collection<MitabStoichiometry> stc;
  MitabStoichiometry var;
    var = stoichiometry(column);
     stc = new ArrayList<MitabStoichiometry>(); if (var != null) {stc.add(var);}
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIELD_SEPARATOR:
        ;
        break;
      default:
        jj_la1[57] = jj_gen;
        break label_14;
      }
      jj_consume_token(FIELD_SEPARATOR);
      var = stoichiometry(column);
                                                    if (var != null) {stc.add(var);}
    }
     {if (true) return stc;}
    throw new Error("Missing return statement in function");
  }

  final public MitabStoichiometry stoichiometry(int columnNumber) throws ParseException {
  int min;
  int max = 0;
  java.lang.String minString;
  java.lang.String maxString = null;
  int beginLine=0;
  int beginColumn=0;
  MitabStoichiometry stc;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //float
          minString = safeStoichiometry();
        beginLine = token.beginLine;
        beginColumn = token.beginColumn;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DASH:
        jj_consume_token(DASH);
        maxString = safeStoichiometry();
        break;
      default:
        jj_la1[58] = jj_gen;
        ;
      }
         try{
         min = Integer.parseInt(minString);
         }
         catch(NumberFormatException e){
             min=0;
             if (getParserListener() != null){getParserListener().onInvalidStoichiometry(e.getMessage(), new DefaultFileSourceContext(new MitabSourceLocator(beginLine, beginColumn, columnNumber)));}
         }
         if (maxString != null){
            try{
            max = Integer.parseInt(maxString);
            }
            catch(NumberFormatException e){
                max=min;
                if (getParserListener() != null){getParserListener().onInvalidStoichiometry(e.getMessage(), new DefaultFileSourceContext(new MitabSourceLocator(beginLine, beginColumn, columnNumber)));}
            }
            try{
            stc = new MitabStoichiometry(min, max);
            }catch(IllegalArgumentException e){
                stc = new MitabStoichiometry(0);
                if (getParserListener() != null){getParserListener().onInvalidStoichiometry(e.getMessage(), stc);}
            }
         }
         else{
            stc = new MitabStoichiometry(min);
         }
         stc.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
         {if (true) return stc;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
        error_skipToNext(enumSet, true);
        {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public F feature(int columnNumber) throws ParseException {
  java.lang.String type;
  Collection<Range> ranges;
  Range var;
  java.lang.String text = null;
  F feature;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //type:range1,range2(text)
          type = safeString();
                         beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      var = range(columnNumber);
     ranges = new ArrayList<Range>(); if (var != null) {ranges.add(var);}
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RANGE_SEPARATOR:
          ;
          break;
        default:
          jj_la1[59] = jj_gen;
          break label_15;
        }
        jj_consume_token(RANGE_SEPARATOR);
        var = range(columnNumber);
                                                  if (var != null) {ranges.add(var);}
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        text = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[60] = jj_gen;
        ;
      }
        feature = createFeature(type, ranges, text, beginLine, beginColumn, columnNumber);

        {if (true) return feature;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet, true);
      {if (true) return null;}
    } catch (IllegalArgumentException e) {
         processSyntaxError(beginLine, beginColumn, columnNumber, e);
         {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabRange range(int columnNumber) throws ParseException {
  Position start;
  Position end;
  java.lang.String startString;
  java.lang.String endString;
  MitabRange range;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.RANGE_SEPARATOR, TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      startString = safePosition();
      beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(DASH);
      endString = safePosition();
        try{
        start = PositionUtils.createPositionFromString(startString);
        }catch(IllegalRangeException e){
            start = PositionUtils.createUndeterminedPosition();
            if (getParserListener() != null){getParserListener().onInvalidPosition(e.getMessage(), new DefaultFileSourceContext(new MitabSourceLocator(beginLine, beginColumn, columnNumber)));}
        }
        catch(IllegalArgumentException e){
            start = PositionUtils.createUndeterminedPosition();
            if (getParserListener() != null){getParserListener().onInvalidPosition(e.getMessage(), new DefaultFileSourceContext(new MitabSourceLocator(beginLine, beginColumn, columnNumber)));}
        }
        try{
        end = PositionUtils.createPositionFromString(endString);
        }catch(IllegalRangeException e){
            end = PositionUtils.createUndeterminedPosition();
            if (getParserListener() != null){getParserListener().onInvalidPosition(e.getMessage(), new DefaultFileSourceContext(new MitabSourceLocator(beginLine, beginColumn, columnNumber)));}
        }
        catch(IllegalArgumentException e){
            end = PositionUtils.createUndeterminedPosition();
            if (getParserListener() != null){getParserListener().onInvalidPosition(e.getMessage(), new DefaultFileSourceContext(new MitabSourceLocator(beginLine, beginColumn, columnNumber)));}
        }
        try{
        range = new MitabRange(start, end);
        range.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        }
        catch(IllegalArgumentException e){
            range = new MitabRange(PositionUtils.createUndeterminedPosition(), PositionUtils.createUndeterminedPosition());
            range.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
            if (getParserListener() != null){getParserListener().onInvalidRange(e.getMessage(), range);}
        }
       {if (true) return range;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet, true);
      {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public boolean negative() throws ParseException {
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
  java.lang.String value;
    try {
      //false or true
          value = safeFreeText();
                             {if (true) return Boolean.parseBoolean(value);}
    } catch (ParseException e) {
    processSyntaxError(token.beginLine, token.beginColumn, 16, e);
     error_skipToNext(enumSet, true);
     {if (true) return false;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabChecksum checksum(int columnNumber) throws ParseException {
  java.lang.String method;
  java.lang.String value;
  MitabChecksum checksum;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //method:value
          method = safeString();
                           beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      value = safeString();
        checksum = new MitabChecksum(method, value);
        checksum.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        if (method == null && getParserListener() != null){getParserListener().onMissingChecksumMethod(checksum);}
        if (value == null && getParserListener() != null){getParserListener().onMissingChecksumValue(checksum);}
        {if (true) return checksum;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
       error_skipToNext(enumSet, true);
        {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabDate date(int columnNumber) throws ParseException {
  java.lang.String date;
  MitabDate mitabDate;
  int beginLine = 0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //yyyy/mm/dd
          date = safeString();
      beginLine = token.beginLine; beginColumn = token.beginColumn; mitabDate = new MitabDate(date);
        mitabDate.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
        {if (true) return mitabDate;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
     error_skipToNext(enumSet, true);
      {if (true) return null;}
    } catch (java.text.ParseException e) {
     processSyntaxError(beginLine, beginColumn, columnNumber, e);
     {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabParameter parameter() throws ParseException {
  java.lang.String type;
  java.lang.String value;
  java.lang.String unit = null;
  MitabParameter param;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //type:value(unit)
          type = safeString();
                         beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      value = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        unit = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[61] = jj_gen;
        ;
      }
     param = new MitabParameter(type, value, unit);
     param.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 30));
     if (type == null && getParserListener() != null){getParserListener().onMissingParameterType(param);}
     if (value == null && getParserListener() != null){getParserListener().onMissingParameterValue(param);}
     {if (true) return param;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, 30, e);
       error_skipToNext(enumSet, true);
       {if (true) return null;}
    } catch (IllegalParameterException e) {
         processSyntaxError(beginLine, beginColumn, 30, e);
         {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabAnnotation annotation(int columnNumber) throws ParseException {
  java.lang.String topic;
  java.lang.String value = null;
  MitabAnnotation annot;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //topic:value
          topic = safeString();
                          beginLine = token.beginLine; beginColumn = token.beginColumn;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        jj_consume_token(COLON);
        value = safeString();
        break;
      default:
        jj_la1[62] = jj_gen;
        ;
      }
      annot = new MitabAnnotation(topic, value);
      annot.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
      if (topic == null && getParserListener() != null){getParserListener().onAnnotationWithoutTopic(annot);}
      {if (true) return annot;}
    } catch (ParseException e) {
         processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
         error_skipToNext(enumSet, true);
         {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabCvTerm expansion() throws ParseException {
  java.lang.String db = null;
  java.lang.String id = null;
  java.lang.String name = null;
  MitabCvTerm cv;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //db:id(name) or just name for backward compatibility
          db = safeString();
                       beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      id = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        name = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
      }
      if (id == null) {cv = new MitabCvTerm(name);
            cv.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 16));
            if (getParserListener() != null) {getParserListener().onMissingExpansionId(cv);}}
      else {cv = new MitabCvTerm(name, null, db, id); cv.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 16));}
      if (name == null && getParserListener() != null){getParserListener().onMissingCvTermName(cv, cv,  "The expansion method at the column 16 does not have a name.");}
      {if (true) return cv;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, 16, e);
     error_skipToNext(enumSet, true);
     {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabConfidence confidence() throws ParseException {
 java.lang.String type;
 java.lang.String value;
 java.lang.String text = null;
  MitabConfidence conf;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      type = safeString();
                         beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      value = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        text = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[64] = jj_gen;
        ;
      }
      if (text == null){conf = new MitabConfidence(type, value, null); conf.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 15));}
      else {conf = new MitabConfidence(type, value, text); conf.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 15));
             if (getParserListener() != null) {getParserListener().onTextFoundInConfidence(conf);}}
      if (type == null && getParserListener() != null){getParserListener().onMissingConfidenceType(conf);}
      if (value == null && getParserListener() != null){getParserListener().onMissingConfidenceValue(conf);}
      {if (true) return conf;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, 15, e);
     error_skipToNext(enumSet, true);
     {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabSource source() throws ParseException {
  java.lang.String db;
  java.lang.String id;
  java.lang.String name = null;
  MitabSource s;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //db:id(name)
             db = safeString();
                          beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      id = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        name = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[65] = jj_gen;
        ;
      }
         s = new MitabSource(name, null, db, id); s.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 13));
         if (name == null && getParserListener() != null){getParserListener().onMissingCvTermName(s, s,  "The source at the column 13 does not have a name.");}
         {if (true) return s;}
    } catch (ParseException e) {
        processSyntaxError(token.beginLine, token.beginColumn, 13, e);
        error_skipToNext(enumSet, true);
        {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabOrganism organism(int columnNumber) throws ParseException {
  java.lang.String id;
  java.lang.String name = null;
  java.lang.String db;
  MitabOrganism organism;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      db = safeString();
     if (!db.equalsIgnoreCase("taxid"))
    { processSyntaxError(token.beginLine, token.beginColumn, columnNumber, new java.lang.RuntimeException("Found " + db + " instead of expected taxid."));
      error_skipToNext(enumSet, false); {if (true) return null;}
      }
      jj_consume_token(COLON);
      id = safeString();
                                beginLine = token.beginLine; beginColumn = token.beginColumn;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        name = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[66] = jj_gen;
        ;
      }
    try{
       int tax = Integer.parseInt(id);
       organism = new MitabOrganism(tax, name);
       organism.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       if ((tax == 0 || tax < -5) && getParserListener() != null){getParserListener().onInvalidOrganismTaxid(id, organism);}
       {if (true) return organism;}
       }catch (NumberFormatException e){
             organism = new MitabOrganism(-3, name);
             organism.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
             if (getParserListener() != null){getParserListener().onInvalidOrganismTaxid(id, organism);}
             {if (true) return organism;}
       }
    } catch (ParseException e) {
           processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
           error_skipToNext(enumSet, true);
           {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabAuthor author() throws ParseException {
 MitabAuthor auth;
 java.lang.String first=null;
 int beginLine;
 int beginColumn;
 EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      first = safeFreeText();
       beginLine = token.beginLine; beginColumn = token.beginColumn;
       auth = new MitabAuthor(first);
       auth.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 8));
       {if (true) return auth;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, 8, e);
       error_skipToNext(enumSet, true);
       {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabCvTerm cvTerm(int column) throws ParseException {
  java.lang.String db;
  java.lang.String id = null;
  java.lang.String name = null;
  int beginLine=0;
  int beginColumn=0;
  MitabCvTerm cv;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      db = safeString();
                       beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      id = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        name = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[67] = jj_gen;
        ;
      }
      cv = new MitabCvTerm(name, null, db, id); cv.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, column));
      if (name == null && getParserListener() != null){getParserListener().onMissingCvTermName(cv, cv,  "The term at the column " + column + " does not have a name.");}
      {if (true) return cv;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, column, e);
     error_skipToNext(enumSet, true);
     {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabAlias alias(int columnNumber) throws ParseException {
  java.lang.String db;
  java.lang.String name;
  java.lang.String type = null;
  int beginLine=0;
  int beginColumn=0;
  MitabAlias alias;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      db = safeString();
                         beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      name = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        type = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[68] = jj_gen;
        ;
      }
        alias = new MitabAlias(db, name, type);
        alias.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        if (db == null && getParserListener() != null){getParserListener().onAliasWithoutDbSource(alias);}
        if (name == null && getParserListener() != null){getParserListener().onAliasWithoutName(alias);}
        {if (true) return alias;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet, true);
      {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabXref id(CvTerm qualifier, boolean recognizeImexPrimary, int columnNumber) throws ParseException {
  java.lang.String db;
  java.lang.String id;
  java.lang.String text = null;
  int beginLine=0;
  int beginColumn=0;
  MitabXref ref;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //db:id(qualifier)
          db = safeString();
                       beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      id = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        text = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[69] = jj_gen;
        ;
      }
      if (recognizeImexPrimary && Xref.IMEX.equalsIgnoreCase(db.trim())){
         if (text == null){ref = new MitabXref(db, id, CvTermUtils.getImexPrimary()); ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));}
         else if (qualifier != null) {ref = new MitabXref(db, id, text);
         ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
         if (getParserListener() != null) {getParserListener().onTextFoundInIdentifier(ref);}}
         else {ref = new MitabXref(db, id, text); ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));}
       }
       else if (text == null) {
         ref = new MitabXref(db, id, qualifier);
         ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       }
       else if (qualifier != null) {
          ref = new MitabXref(db, id, text);
          ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
          if (getParserListener() != null) {getParserListener().onTextFoundInIdentifier(ref);}
       }
       else{
          ref = new MitabXref(db, id, text);
          ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       }
       if (db == null && getParserListener() != null){getParserListener().onXrefWithoutDatabase(ref);}
       if (id == null && getParserListener() != null){getParserListener().onXrefWithoutId(ref);}
       {if (true) return ref;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet, true);
      {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public java.lang.String safeString() throws ParseException {
  java.lang.String result = null;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.COLON, TokenKind.OPEN_PAREN, TokenKind.CLOSE_PAREN, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_STRING:
      jj_consume_token(QUOTED_STRING);
                     result = MitabUtils.unescapeDoubleQuote(token.image.substring(1,token.image.length() - 1).trim());
      break;
    default:
      jj_la1[70] = jj_gen;
      result = anyStringBut(enumSet);
    }
   {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public java.lang.String safeFreeText() throws ParseException {
  java.lang.String result = null;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_STRING:
      jj_consume_token(QUOTED_STRING);
                     result = MitabUtils.unescapeDoubleQuote(token.image.substring(1,token.image.length() - 1).trim());
      break;
    default:
      jj_la1[71] = jj_gen;
      result = anyStringBut(enumSet);
    }
   {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public java.lang.String safePosition() throws ParseException {
  java.lang.String result = null;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.DASH, TokenKind.RANGE_SEPARATOR, TokenKind.FIELD_SEPARATOR, TokenKind.OPEN_PAREN, TokenKind.CLOSE_PAREN, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_STRING:
      jj_consume_token(QUOTED_STRING);
                     result = MitabUtils.unescapeDoubleQuote(token.image.substring(1,token.image.length() - 1).trim());
      break;
    default:
      jj_la1[72] = jj_gen;
      result = anyStringBut(enumSet);
    }
   {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public java.lang.String safeStoichiometry() throws ParseException {
  java.lang.String result = null;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.DASH, TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_STRING:
      jj_consume_token(QUOTED_STRING);
                     result = MitabUtils.unescapeDoubleQuote(token.image.substring(1,token.image.length() - 1).trim());
      break;
    default:
      jj_la1[73] = jj_gen;
      result = anyStringBut(enumSet);
    }
   {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  java.lang.String anyStringBut(EnumSet<TokenKind> skipToTokens) throws ParseException {
  java.lang.StringBuilder result = resetStringBuilder();

  Token t = getToken(1);
  // next token is 1
  while(t.kind != EOF && !skipToTokens.contains(TokenKind.getFromTokenKind(t.kind))){
      t = getNextToken();
      // check next token
      result.append(t.image);
      t = getToken(1);
  }
  java.lang.String resultStr = result.toString().trim();
  return resultStr.length() > 0 ? resultStr : null;
  }

  void error_skipToNext(EnumSet<TokenKind> skipToTokens, boolean writeError) throws ParseException {
   if (writeError){
    ParseException e = generateParseException();  // generate the exception object.
    System.out.println(e.toString());  // print the error message
   }

  Token t = getToken(0);
  while(t.kind != EOF && !skipToTokens.contains(TokenKind.getFromTokenKind(t.kind))){
     // check next token
     t = getNextToken();
  }
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_3_2() {
    if (jj_scan_token(DASH)) return true;
    if (jj_scan_token(COLUMN_SEPARATOR)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(DASH)) return true;
    if (jj_scan_token(COLUMN_SEPARATOR)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(DASH)) return true;
    if (jj_scan_token(COLUMN_SEPARATOR)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public MitabLineParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[74];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x81,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x800,0x40,0x40,0x81,0x91,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x800,0x8,0x100,0x100,0x400,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x1000,0x1000,0x1000,0x1000,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[3];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public MitabLineParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public MitabLineParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new MitabLineParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public MitabLineParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new MitabLineParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public MitabLineParser(MitabLineParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(MitabLineParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[14];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 74; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 14; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 3; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
