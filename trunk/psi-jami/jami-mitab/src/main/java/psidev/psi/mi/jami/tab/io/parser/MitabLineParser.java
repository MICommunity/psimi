/* Generated By:JavaCC: Do not edit this line. MitabLineParser.java */
package psidev.psi.mi.jami.tab.io.parser;

import psidev.psi.mi.jami.model.*;
import psidev.psi.mi.jami.tab.extension.*;
import psidev.psi.mi.jami.tab.listener.MitabParserListener;
import java.util.Collection;
import java.util.Collections;
import psidev.psi.mi.jami.utils.CvTermUtils;
import psidev.psi.mi.jami.utils.PositionUtils;
import java.util.ArrayList;
import java.util.EnumSet;
import java.lang.NumberFormatException;
import psidev.psi.mi.jami.exception.IllegalParameterException;
import psidev.psi.mi.jami.exception.IllegalRangeException;
import psidev.psi.mi.jami.tab.utils.MitabUtils;

public abstract class MitabLineParser<T extends Interaction, P extends Participant> implements MitabLineParserConstants {

        void processSyntaxError(int lineNumber, int columnNumber, int mitabColumn, Exception e) {
            fireOnInvalidSyntax(lineNumber, columnNumber, mitabColumn, e);
        }

        public abstract MitabParserListener getParserListener();

        public abstract void setParserListener(MitabParserListener listener);

    abstract void fireOnInvalidSyntax(int lineNumber, int columnNumber, int mitabColumn, Exception e);

    abstract void reachEndOfFile();

    public abstract boolean hasFinished();

        abstract P finishParticipant(Collection<MitabXref> uniqueId, Collection<MitabXref> altid , Collection<MitabAlias> aliases,
                                               Collection<MitabOrganism> taxid, Collection<MitabCvTerm> bioRole, Collection<MitabCvTerm> expRole,
                                               Collection<MitabCvTerm> type, Collection<MitabXref> xref, Collection<MitabAnnotation> annot,
                                               Collection<MitabChecksum> checksum, Collection<MitabFeature> feature, Collection<MitabStoichiometry> stc,
                                               Collection<MitabCvTerm> detMethod, int line, int column, int mitabColumn);
        abstract T finishInteraction(P A, P B, Collection<MitabCvTerm> detMethod, Collection<MitabAuthor> firstAuthor,
                                               Collection<MitabXref> pubId, Collection<MitabCvTerm> interactionType, Collection<MitabSource> source,
                                               Collection<MitabXref> interactionId, Collection<MitabConfidence> conf, Collection<MitabCvTerm> expansion,
                                               Collection<MitabXref> xrefI, Collection<MitabAnnotation> annotI, Collection<MitabOrganism> host,
                                               Collection<MitabParameter> params, Collection<MitabDate> created, Collection<MitabDate> update,
                                               Collection<MitabChecksum> checksumI, boolean isNegative, int line);

  final public T MitabLine() throws ParseException {
  Collection<MitabXref> uniqueIdA;
  Collection<MitabXref> uniqueIdB;
  Collection<MitabXref> altIdA;
  Collection<MitabXref> altIdB;
  Collection<MitabAlias> aliasA;
  Collection<MitabAlias> aliasB;
  Collection<MitabCvTerm> detMethod;
  Collection<MitabAuthor> firstAuthor;
  Collection<MitabXref> pubId;
  Collection<MitabOrganism> taxidA;
  Collection<MitabOrganism> taxidB;
  Collection<MitabCvTerm> interactionType;
  Collection<MitabSource> source;
  Collection<MitabXref> interactionId;
  Collection<MitabConfidence> conf;
  Collection<MitabCvTerm> expansion = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> bioRoleA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> bioRoleB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> expRoleA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> expRoleB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> typeA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> typeB = Collections.EMPTY_LIST;
  Collection<MitabXref> xrefA = Collections.EMPTY_LIST;
  Collection<MitabXref> xrefB = Collections.EMPTY_LIST;
  Collection<MitabXref> xrefI = Collections.EMPTY_LIST;
  Collection<MitabAnnotation> annotA = Collections.EMPTY_LIST;
  Collection<MitabAnnotation> annotB = Collections.EMPTY_LIST;
  Collection<MitabAnnotation> annotI = Collections.EMPTY_LIST;
  Collection<MitabOrganism> host = Collections.EMPTY_LIST;
  Collection<MitabParameter> params = Collections.EMPTY_LIST;
  Collection<MitabDate> created = Collections.EMPTY_LIST;
  Collection<MitabDate> update = Collections.EMPTY_LIST;
  Collection<MitabChecksum> checksumA = Collections.EMPTY_LIST;
  Collection<MitabChecksum> checksumB = Collections.EMPTY_LIST;
  Collection<MitabChecksum> checksumI = Collections.EMPTY_LIST;
  boolean isNegative = false;
  Collection<MitabFeature> featureA = Collections.EMPTY_LIST;
  Collection<MitabFeature> featureB = Collections.EMPTY_LIST;
  Collection<MitabStoichiometry> stcA = Collections.EMPTY_LIST;
  Collection<MitabStoichiometry> stcB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> pmethodA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> pmethodB = Collections.EMPTY_LIST;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR);
  P participantA;
  P participantB;
  T interaction=null;
  int line;
  int columnA;
  int columnB;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMENT:
        jj_consume_token(COMMENT);
        break;
      default:
        jj_la1[44] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                 uniqueIdA = Collections.EMPTY_LIST; line = token.beginLine; columnA = token.beginColumn;
          break;
        default:
          jj_la1[0] = jj_gen;
          uniqueIdA = ids(CvTermUtils.createIdentityXrefQualifier(), false, 1);
        }
                                                                                                                                                                                    line = token.beginLine; columnA = token.beginColumn;
        jj_consume_token(COLUMN_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                 uniqueIdB = Collections.EMPTY_LIST; columnB = token.beginColumn;
          break;
        default:
          jj_la1[1] = jj_gen;
          uniqueIdB = ids(CvTermUtils.createIdentityXrefQualifier(), false, 2);
        }
                                                                                                                                                            columnB = token.beginColumn;
        jj_consume_token(COLUMN_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                 altIdA = Collections.EMPTY_LIST;
          break;
        default:
          jj_la1[2] = jj_gen;
          altIdA = ids(CvTermUtils.createSecondaryXrefQualifier(), false, 3);
        }
        jj_consume_token(COLUMN_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                 altIdB = Collections.EMPTY_LIST;
          break;
        default:
          jj_la1[3] = jj_gen;
          altIdB = ids(CvTermUtils.createSecondaryXrefQualifier(), false, 4);
        }
        jj_consume_token(COLUMN_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                 aliasA = Collections.EMPTY_LIST;
          break;
        default:
          jj_la1[4] = jj_gen;
          aliasA = aliases(5);
        }
        jj_consume_token(COLUMN_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                 aliasB = Collections.EMPTY_LIST;
          break;
        default:
          jj_la1[5] = jj_gen;
          aliasB = aliases(6);
        }
        jj_consume_token(COLUMN_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                 detMethod = Collections.EMPTY_LIST;
          break;
        default:
          jj_la1[6] = jj_gen;
          detMethod = cvTerms(7);
        }
        jj_consume_token(COLUMN_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                 firstAuthor = Collections.EMPTY_LIST;
          break;
        default:
          jj_la1[7] = jj_gen;
          firstAuthor = firstAuthors();
        }
        jj_consume_token(COLUMN_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                 pubId = Collections.EMPTY_LIST;
          break;
        default:
          jj_la1[8] = jj_gen;
          pubId = ids(CvTermUtils.createIdentityXrefQualifier(), true, 9);
        }
        jj_consume_token(COLUMN_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                 taxidA = Collections.EMPTY_LIST;
          break;
        case TAXID:
          taxidA = taxId(10);
          break;
        default:
          jj_la1[9] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(COLUMN_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                 taxidB = Collections.EMPTY_LIST;
          break;
        case TAXID:
          taxidB = taxId(11);
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(COLUMN_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                 interactionType = Collections.EMPTY_LIST;
          break;
        default:
          jj_la1[11] = jj_gen;
          interactionType = cvTerms(12);
        }
        jj_consume_token(COLUMN_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                 source = Collections.EMPTY_LIST;
          break;
        default:
          jj_la1[12] = jj_gen;
          source = sourceDbs();
        }
        jj_consume_token(COLUMN_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                 interactionId = Collections.EMPTY_LIST;
          break;
        default:
          jj_la1[13] = jj_gen;
          interactionId = ids(CvTermUtils.createIdentityXrefQualifier(), true, 14);
        }
        jj_consume_token(COLUMN_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                 conf = Collections.EMPTY_LIST;
          break;
        default:
          jj_la1[14] = jj_gen;
          conf = confidences();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COLUMN_SEPARATOR:
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 expansion = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[15] = jj_gen;
            expansion = complexExpansion();
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 bioRoleA = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[16] = jj_gen;
            bioRoleA = cvTerms(17);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 bioRoleB = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[17] = jj_gen;
            bioRoleB = cvTerms(18);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 expRoleA = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[18] = jj_gen;
            expRoleA = cvTerms(19);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 expRoleB = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[19] = jj_gen;
            expRoleB = cvTerms(20);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 typeA = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[20] = jj_gen;
            typeA = cvTerms(21);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 typeB = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[21] = jj_gen;
            typeB = cvTerms(22);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 xrefA = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[22] = jj_gen;
            xrefA = ids(null, false, 23);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 xrefB = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[23] = jj_gen;
            xrefB = ids(null, false, 24);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 xrefI = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[24] = jj_gen;
            xrefI = ids(null, false, 25);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 annotA = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[25] = jj_gen;
            annotA = annotations(26);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 annotB = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[26] = jj_gen;
            annotB = annotations(27);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 annotI = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[27] = jj_gen;
            annotI = annotations(28);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 host = Collections.EMPTY_LIST;
            break;
          case TAXID:
            host = taxId(29);
            break;
          default:
            jj_la1[28] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 params = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[29] = jj_gen;
            params = parameters();
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 created = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[30] = jj_gen;
            created = dates(31);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 update = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[31] = jj_gen;
            update = dates(32);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 checksumA = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[32] = jj_gen;
            checksumA = checksums(33);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 checksumB = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[33] = jj_gen;
            checksumB = checksums(34);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
                 checksumI = Collections.EMPTY_LIST;
            break;
          default:
            jj_la1[34] = jj_gen;
            checksumI = checksums(35);
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            jj_consume_token(DASH);
            break;
          case NEGATIVE:
            isNegative = negative();
            break;
          default:
            jj_la1[35] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COLUMN_SEPARATOR:
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                 featureA = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[36] = jj_gen;
              featureA = features(37);
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                 featureB = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[37] = jj_gen;
              featureB = features(38);
            }
            jj_consume_token(COLUMN_SEPARATOR);
            if (jj_2_1(2)) {
              jj_consume_token(DASH);
                              stcA = Collections.EMPTY_LIST;
            } else {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case PUB_DATE:
              case NUMBER:
              case STOICHIOMETRY:
              case DASH:
                stcA = stoichiometryList(39);
                break;
              default:
                jj_la1[38] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
            jj_consume_token(COLUMN_SEPARATOR);
            if (jj_2_2(2)) {
              jj_consume_token(DASH);
                              stcB = Collections.EMPTY_LIST;
            } else {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case PUB_DATE:
              case NUMBER:
              case STOICHIOMETRY:
              case DASH:
                stcB = stoichiometryList(40);
                break;
              default:
                jj_la1[39] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                 pmethodA = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[40] = jj_gen;
              pmethodA = cvTerms(41);
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              jj_consume_token(DASH);
                 pmethodB = Collections.EMPTY_LIST;
              break;
            default:
              jj_la1[41] = jj_gen;
              pmethodB = cvTerms(42);
            }
            break;
          default:
            jj_la1[42] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[43] = jj_gen;
          ;
        }
        participantA = finishParticipant(uniqueIdA, altIdA, aliasA, taxidA, bioRoleA, expRoleA, typeA, xrefA, annotA, checksumA, featureA, stcA, pmethodA, line, columnA, 1);
        participantB = finishParticipant(uniqueIdB, altIdB, aliasB, taxidB, bioRoleB, expRoleB, typeB, xrefB, annotB, checksumB, featureB, stcB, pmethodB, line, columnB, 2);
        interaction = finishInteraction(participantA, participantB, detMethod, firstAuthor, pubId, interactionType, source, interactionId,
                                 conf, expansion, xrefI, annotI, host, params, created, update, checksumI, isNegative, line);
      }
    } catch (ParseException e) {
        processSyntaxError(token.beginLine, token.beginColumn, 0, e);
        error_skipToNext(enumSet);
        {if (true) return null;}
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LINE_SEPARATOR:
      jj_consume_token(LINE_SEPARATOR);
                          {if (true) return interaction;}
      break;
    case 0:
      jj_consume_token(0);
              reachEndOfFile(); {if (true) return interaction;}
      break;
    default:
      jj_la1[45] = jj_gen;
      error_skipToNext(enumSet);
                                 {if (true) return interaction;}
    }
    {if (true) return interaction;}
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabXref> ids(CvTerm qualifier, boolean recognizeImex, int column) throws ParseException {
  Collection<MitabXref> xrefs;
  MitabXref var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = id(qualifier, recognizeImex, column);
          xrefs = new ArrayList<MitabXref>(); if (var != null) {xrefs.add(var);}
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[46] = jj_gen;
          break label_1;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = id(qualifier, recognizeImex, column);
                                                                   if (var != null) {xrefs.add(var);}
      }
     {if (true) return xrefs;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, column, e);
      error_skipToNext(enumSet);
       {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabAlias> aliases(int column) throws ParseException {
  Collection<MitabAlias> aliases;
  MitabAlias var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = alias(column);
     aliases = new ArrayList<MitabAlias>(); if (var != null) {if (var != null) {aliases.add(var);}}
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[47] = jj_gen;
          break label_2;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = alias(column);
                                            if (var != null) {if (var != null) {aliases.add(var);}}
      }
     {if (true) return aliases;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, column, e);
      error_skipToNext(enumSet);
       {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabCvTerm> cvTerms(int columnNumber) throws ParseException {
  Collection<MitabCvTerm> methods;
  MitabCvTerm var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = cvTerm(columnNumber);
     methods = new ArrayList<MitabCvTerm>(); if (var != null) {methods.add(var);}
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[48] = jj_gen;
          break label_3;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = cvTerm(columnNumber);
                                                   if (var != null) {methods.add(var);}
      }
     {if (true) return methods;}
    } catch (ParseException e) {
    processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
    error_skipToNext(enumSet);
     {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabAuthor> firstAuthors() throws ParseException {
  Collection<MitabAuthor> authors;
  MitabAuthor var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = author();
     authors = new ArrayList<MitabAuthor>(); if (var != null) {authors.add(var);}
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[49] = jj_gen;
          break label_4;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = author();
                                       if (var != null) {authors.add(var);}
      }
     {if (true) return authors;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, 8, e);
        error_skipToNext(enumSet);
        {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabOrganism> taxId(int column) throws ParseException {
  Collection<MitabOrganism> organisms;
  MitabOrganism var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = organism(column);
     organisms = new ArrayList<MitabOrganism>(); if (var != null) {organisms.add(var);}
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[50] = jj_gen;
          break label_5;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = organism(column);
                                               if (var != null) {organisms.add(var);}
      }
     {if (true) return organisms;}
    } catch (ParseException e) {
         processSyntaxError(token.beginLine, token.beginColumn, column, e);
         error_skipToNext(enumSet);
         {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabSource> sourceDbs() throws ParseException {
  Collection<MitabSource> sources;
  MitabSource var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = source();
     sources = new ArrayList<MitabSource>(); if (var != null) {sources.add(var);}
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[51] = jj_gen;
          break label_6;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = source();
                                       if (var != null) {sources.add(var);}
      }
     {if (true) return sources;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, 13, e);
       error_skipToNext(enumSet);
       {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabConfidence> confidences() throws ParseException {
  Collection<MitabConfidence> confs;
  MitabConfidence var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = confidence();
     confs = new ArrayList<MitabConfidence>(); if (var != null) {confs.add(var);}
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[52] = jj_gen;
          break label_7;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = confidence();
                                           if (var != null) {confs.add(var);}
      }
     {if (true) return confs;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, 15, e);
       error_skipToNext(enumSet);
       {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabCvTerm> complexExpansion() throws ParseException {
  Collection<MitabCvTerm> expansions;
  MitabCvTerm var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = expansion();
     expansions = new ArrayList<MitabCvTerm>(); if (var != null) {expansions.add(var);}
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[53] = jj_gen;
          break label_8;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = expansion();
                                          if (var != null) {expansions.add(var);}
      }
     {if (true) return expansions;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, 16, e);
     error_skipToNext(enumSet);
     {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabAnnotation> annotations(int column) throws ParseException {
  Collection<MitabAnnotation> annots;
  MitabAnnotation var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = annotation(column);
       annots = new ArrayList<MitabAnnotation>(); if (var != null) {annots.add(var);}
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[54] = jj_gen;
          break label_9;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = annotation(column);
                                                   if (var != null) {annots.add(var);}
      }
       {if (true) return annots;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, column, e);
      error_skipToNext(enumSet);
      {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabParameter> parameters() throws ParseException {
  Collection<MitabParameter> params;
  MitabParameter var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = parameter();
     params = new ArrayList<MitabParameter>(); if (var != null) {params.add(var);}
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[55] = jj_gen;
          break label_10;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = parameter();
                                          if (var != null) {params.add(var);}
      }
     {if (true) return params;}
    } catch (ParseException e) {
         processSyntaxError(token.beginLine, token.beginColumn, 30, e);
         error_skipToNext(enumSet);
         {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabDate> dates(int column) throws ParseException {
  Collection<MitabDate> dates;
  MitabDate var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = date(column);
       dates = new ArrayList<MitabDate>(); if (var != null) {if (var != null) {dates.add(var);}}
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[56] = jj_gen;
          break label_11;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = date(column);
                                             if (var != null) {if (var != null) {if (var != null) {dates.add(var);}}}
      }
       {if (true) return dates;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, column, e);
       error_skipToNext(enumSet);
       {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabChecksum> checksums(int column) throws ParseException {
  Collection<MitabChecksum> checksums;
  MitabChecksum var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = checksum(column);
       checksums = new ArrayList<MitabChecksum>(); if (var != null) {checksums.add(var);}
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[57] = jj_gen;
          break label_12;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = checksum(column);
                                                 if (var != null) {checksums.add(var);}
      }
       {if (true) return checksums;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, column, e);
     error_skipToNext(enumSet);
     {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabFeature> features(int column) throws ParseException {
  Collection<MitabFeature> features;
  MitabFeature var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = feature(column);
        features = new ArrayList<MitabFeature>(); if (var != null) {features.add(var);}
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[58] = jj_gen;
          break label_13;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = feature(column);
                                                 if (var != null) {features.add(var);}
      }
        {if (true) return features;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, column, e);
       error_skipToNext(enumSet);
       {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabStoichiometry> stoichiometryList(int column) throws ParseException {
  Collection<MitabStoichiometry> stc;
  MitabStoichiometry var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = stoichiometry(column);
     stc = new ArrayList<MitabStoichiometry>(); if (var != null) {stc.add(var);}
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[59] = jj_gen;
          break label_14;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = stoichiometry(column);
                                                    if (var != null) {stc.add(var);}
      }
     {if (true) return stc;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, column, e);
     error_skipToNext(enumSet);
     {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabStoichiometry stoichiometry(int columnNumber) throws ParseException {
  long min;
  long max = 0;
  java.lang.String minString;
  java.lang.String maxString = null;
  int beginLine;
  int beginColumn;
  MitabStoichiometry stc;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //float
          minString = safeStoichiometry();
        min = Long.parseLong(minString);
        beginLine = token.beginLine;
        beginColumn = token.beginColumn;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DASH:
        jj_consume_token(DASH);
        maxString = safeStoichiometry();
            max = Long.parseLong(maxString);
        break;
      default:
        jj_la1[60] = jj_gen;
        ;
      }
         if (maxString != null){
            stc = new MitabStoichiometry(min, max);
         }
         else{
            stc = new MitabStoichiometry(min);
         }
         stc.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
         {if (true) return stc;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
        error_skipToNext(enumSet);
        {if (true) return null;}
    } catch (NumberFormatException e) {
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
       error_skipToNext(enumSet);
       {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabFeature feature(int columnNumber) throws ParseException {
  java.lang.String type;
  Collection<Range> ranges;
  Range var;
  java.lang.String text;
  MitabFeature feature;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //type:range1,range2(text)
          type = safeString();
                         beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      var = range(columnNumber);
     ranges = new ArrayList<Range>(); if (var != null) {ranges.add(var);}
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RANGE_SEPARATOR:
          ;
          break;
        default:
          jj_la1[61] = jj_gen;
          break label_15;
        }
        jj_consume_token(RANGE_SEPARATOR);
        var = range(columnNumber);
                                                  if (var != null) {ranges.add(var);}
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        text = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[62] = jj_gen;
        ;
      }
        feature = new MitabFeature(type);
        feature.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        feature.getRanges().addAll(ranges);

        {if (true) return feature;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet);
      {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabRange range(int columnNumber) throws ParseException {
  Position start;
  Position end;
  java.lang.String startString;
  java.lang.String endString;
  MitabRange range;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.RANGE_SEPARATOR, TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      startString = safePosition();
      beginLine = token.beginLine; beginColumn = token.beginColumn;
      start = PositionUtils.createPositionFromString(startString);
      jj_consume_token(DASH);
      endString = safePosition();
    end = PositionUtils.createPositionFromString(endString);
       range = new MitabRange(start, end);
        range.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       {if (true) return range;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet);
      {if (true) return null;}
    } catch (IllegalRangeException e) {
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
       error_skipToNext(enumSet);
       {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public boolean negative() throws ParseException {
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      jj_consume_token(NEGATIVE);
        {if (true) return Boolean.parseBoolean(token.image.trim());}
    } catch (ParseException e) {
    processSyntaxError(token.beginLine, token.beginColumn, 16, e);
     error_skipToNext(enumSet);
     {if (true) return false;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabChecksum checksum(int columnNumber) throws ParseException {
  java.lang.String method;
  java.lang.String value;
  MitabChecksum checksum;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //method:value
          method = safeString();
                           beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      value = safeString();
        checksum = new MitabChecksum(method, value);
        checksum.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        {if (true) return checksum;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
       error_skipToNext(enumSet);
        {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabDate date(int columnNumber) throws ParseException {
  java.lang.String date;
  MitabDate mitabDate;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //yyyy/mm/dd
          date = safeString();
      mitabDate = new MitabDate(date);
        mitabDate.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
        {if (true) return mitabDate;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
     error_skipToNext(enumSet);
      {if (true) return null;}
    } catch (java.text.ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
     error_skipToNext(enumSet);
     {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabParameter parameter() throws ParseException {
  java.lang.String type;
  java.lang.String value;
  java.lang.String unit = null;
  MitabParameter param;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //type:value(unit)
          type = safeString();
                         beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      value = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        unit = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
      }
     param = new MitabParameter(type, value, unit);
     param.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 30));
     {if (true) return param;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, 30, e);
       error_skipToNext(enumSet);
       {if (true) return null;}
    } catch (IllegalParameterException e) {
      processSyntaxError(token.beginLine, token.beginColumn, 30, e);
      error_skipToNext(enumSet);
      {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabAnnotation annotation(int columnNumber) throws ParseException {
  java.lang.String topic;
  java.lang.String value = null;
  MitabAnnotation annot;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //topic:value
          topic = safeString();
                          beginLine = token.beginLine; beginColumn = token.beginColumn;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        jj_consume_token(COLON);
        value = safeString();
        break;
      default:
        jj_la1[64] = jj_gen;
        ;
      }
      annot = new MitabAnnotation(topic, value);
      annot.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
      {if (true) return annot;}
    } catch (ParseException e) {
         processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
         error_skipToNext(enumSet);
         {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabXref xref(int columnNumber) throws ParseException {
  java.lang.String db;
  java.lang.String id;
  java.lang.String text = null;
  MitabXref ref;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //db:id(qualifier)
          db = safeString();
                       beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      id = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        text = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[65] = jj_gen;
        ;
      }
      ref = new MitabXref(db, id, text);
      ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
      {if (true) return ref;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
       error_skipToNext(enumSet);
       {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabCvTerm expansion() throws ParseException {
  java.lang.String db = null;
  java.lang.String id = null;
  java.lang.String name = null;
  MitabCvTerm cv;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //db:id(name) or just name for backward compatibility
          db = safeString();
                       beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      id = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        name = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[66] = jj_gen;
        ;
      }
      if (name == null){cv = new MitabCvTerm(MitabUtils.UNKNOWN_DATABASE, null, db, id);
           cv.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 16));
           if (getParserListener() != null) {getParserListener().onMissingCvTermName(cv, cv, "The complex expansion method does not have a name.");}}
      else if (id == null) {cv = new MitabCvTerm(name);
            cv.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 16));
            if (getParserListener() != null) {getParserListener().onMissingExpansionId(cv);}}
      else {cv = new MitabCvTerm(name, null, db, id); cv.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 16));}
      {if (true) return cv;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, 16, e);
     error_skipToNext(enumSet);
     {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabConfidence confidence() throws ParseException {
 java.lang.String type;
 java.lang.String value;
 java.lang.String text = null;
  MitabConfidence conf;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      type = safeString();
                         beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      value = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        text = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[67] = jj_gen;
        ;
      }
      if (text == null){conf = new MitabConfidence(type, value, null); conf.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 15));}
      else {conf = new MitabConfidence(type, value, text); conf.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 15));
             if (getParserListener() != null) {getParserListener().onTextFoundInConfidence(conf);}}
      {if (true) return conf;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, 15, e);
     error_skipToNext(enumSet);
     {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabSource source() throws ParseException {
  java.lang.String db;
  java.lang.String id;
  java.lang.String name = null;
  MitabSource s;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //db:id(name)
             db = safeString();
                          beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      id = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        name = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[68] = jj_gen;
        ;
      }
         if (name == null){s = new MitabSource(MitabUtils.UNKNOWN_DATABASE, null, db, id); s.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 13));
            if (getParserListener() != null) {getParserListener().onMissingCvTermName(s, s, "The interaction source does not have a name.");}}
         else {s = new MitabSource(name, null, db, id); s.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 13));}
         {if (true) return s;}
    } catch (ParseException e) {
        processSyntaxError(token.beginLine, token.beginColumn, 13, e);
        error_skipToNext(enumSet);
        {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabOrganism organism(int columnNumber) throws ParseException {
  java.lang.String id;
  java.lang.String name = null;
  MitabOrganism organism;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      jj_consume_token(TAXID);
      jj_consume_token(COLON);
      id = safeString();
                                       beginLine = token.beginLine; beginColumn = token.beginColumn;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        name = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[69] = jj_gen;
        ;
      }
       organism = new MitabOrganism(Integer.parseInt(id), name);
       organism.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       {if (true) return organism;}
    } catch (ParseException e) {
           processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
           error_skipToNext(enumSet);
           {if (true) return null;}
    } catch (NumberFormatException e) {
           processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
           error_skipToNext(enumSet);
           {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabAuthor author() throws ParseException {
 MitabAuthor auth;
 java.lang.String first=null;
 java.lang.String date = null;
 int beginLine;
 int beginColumn;
 EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PUB_DATE:
        jj_consume_token(PUB_DATE);
                    date = token.image.trim(); beginLine = token.beginLine; beginColumn = token.beginColumn;
        first = safeAuthor();
        break;
      default:
        jj_la1[71] = jj_gen;
        first = safeAuthor();
                               beginLine = token.beginLine; beginColumn = token.beginColumn;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_PAREN:
          jj_consume_token(OPEN_PAREN);
          jj_consume_token(PUB_DATE);
                                                                                                                         date = token.image.trim();
          jj_consume_token(CLOSE_PAREN);
          break;
        default:
          jj_la1[70] = jj_gen;
          ;
        }
      }
       beginLine = token.beginLine; beginColumn = token.beginColumn;
       if (date == null){auth = new MitabAuthor(first);}
       else{ auth = new MitabAuthor(first, date);}
       auth.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 8));
       {if (true) return auth;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, 8, e);
       error_skipToNext(enumSet);
       {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabCvTerm cvTerm(int column) throws ParseException {
  java.lang.String db;
  java.lang.String id = null;
  java.lang.String name = null;
  int beginLine;
  int beginColumn;
  MitabCvTerm cv;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      db = safeString();
                       beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      id = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        name = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[72] = jj_gen;
        ;
      }
      if (name == null){cv = new MitabCvTerm(MitabUtils.UNKNOWN_DATABASE, null, db, id); cv.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, column));
          if (getParserListener() != null){getParserListener().onMissingCvTermName(cv, cv, "The term at the column " + column + " does not have a name.");}}
      else {cv = new MitabCvTerm(name, null, db, id); cv.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, column));}
      {if (true) return cv;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, column, e);
     error_skipToNext(enumSet);
     {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabAlias alias(int columnNumber) throws ParseException {
  java.lang.String db;
  java.lang.String name;
  java.lang.String type = null;
  int beginLine;
  int beginColumn;
  MitabAlias alias;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      db = safeString();
                         beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      name = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        type = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[73] = jj_gen;
        ;
      }
        alias = new MitabAlias(db, name, type);
        alias.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        {if (true) return alias;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet);
      {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabXref id(CvTerm qualifier, boolean recognizeImexPrimary, int columnNumber) throws ParseException {
  java.lang.String db;
  java.lang.String id;
  java.lang.String text = null;
  int beginLine;
  int beginColumn;
  MitabXref ref;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //db:id(qualifier)
          db = safeString();
                       beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(COLON);
      id = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        text = safeString();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[74] = jj_gen;
        ;
      }
      if (recognizeImexPrimary && Xref.IMEX.equalsIgnoreCase(db.trim())){
         if (text == null){ref = new MitabXref(db, id, CvTermUtils.createImexPrimaryQualifier()); ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));}
         else if (qualifier != null) {ref = new MitabXref(db, id, text);
         ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
         if (getParserListener() != null) {getParserListener().onTextFoundInIdentifier(ref);}}
         else {ref = new MitabXref(db, id, text); ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));}
       }
       else if (text == null) {
         ref = new MitabXref(db, id, qualifier);
         ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       }
       else if (qualifier != null) {
          ref = new MitabXref(db, id, text);
          ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
          if (getParserListener() != null) {getParserListener().onTextFoundInIdentifier(ref);}
       }
       else{
          ref = new MitabXref(db, id, text);
          ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       }
       {if (true) return ref;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet);
      {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public java.lang.String safeString() throws ParseException {
  java.lang.String result = null;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.COLON, TokenKind.OPEN_PAREN, TokenKind.CLOSE_PAREN, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_STRING:
      jj_consume_token(QUOTED_STRING);
                     result = token.image.trim();
      break;
    default:
      jj_la1[75] = jj_gen;
      result = anyStringBut(enumSet);
    }
   {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public java.lang.String safeAuthor() throws ParseException {
  java.lang.String result = null;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.OPEN_PAREN, TokenKind.CLOSE_PAREN,TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_STRING:
      jj_consume_token(QUOTED_STRING);
                     result = token.image.trim();
      break;
    default:
      jj_la1[76] = jj_gen;
      result = anyStringBut(enumSet);
    }
   {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public java.lang.String safePosition() throws ParseException {
 java.lang.StringBuilder text = new StringBuilder();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POSITION:
      jj_consume_token(POSITION);
               text.append(token.image);
      break;
    case LESSTHAN:
      jj_consume_token(LESSTHAN);
                  text.append(token.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DASH:
        jj_consume_token(DASH);
        break;
      default:
        jj_la1[77] = jj_gen;
        ;
      }
                                                        text.append(token.image);
      jj_consume_token(NUMBER);
                                                                                             text.append(token.image);
      break;
    case GREATERTHAN:
      jj_consume_token(GREATERTHAN);
                     text.append(token.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DASH:
        jj_consume_token(DASH);
        break;
      default:
        jj_la1[78] = jj_gen;
        ;
      }
                                                           text.append(token.image);
      jj_consume_token(NUMBER);
                                                                                                text.append(token.image);
      break;
    case NUMBER:
    case DASH:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DASH:
        jj_consume_token(DASH);
                text.append(token.image);
        break;
      default:
        jj_la1[79] = jj_gen;
        ;
      }
      jj_consume_token(NUMBER);
                                                      text.append(token.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 22:
        jj_consume_token(22);
               text.append(token.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          jj_consume_token(DASH);
                     text.append(token.image);
          break;
        default:
          jj_la1[80] = jj_gen;
          ;
        }
        jj_consume_token(NUMBER);
                                                           text.append(token.image);
        break;
      default:
        jj_la1[81] = jj_gen;
        ;
      }
      break;
    case PUB_DATE:
      jj_consume_token(PUB_DATE);
                 text.append(token.image);
      break;
    default:
      jj_la1[82] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
   {if (true) return text.toString();}
    throw new Error("Missing return statement in function");
  }

  final public java.lang.String safeStoichiometry() throws ParseException {
 java.lang.String text;
 java.lang.String sign = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DASH:
      jj_consume_token(DASH);
         sign = token.image;
      break;
    default:
      jj_la1[83] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STOICHIOMETRY:
      jj_consume_token(STOICHIOMETRY);
                                                text = token.image;
      break;
    case PUB_DATE:
      jj_consume_token(PUB_DATE);
                 text = token.image;
      break;
    case NUMBER:
      jj_consume_token(NUMBER);
               text = token.image;
      break;
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
   {if (true) return sign+text;}
    throw new Error("Missing return statement in function");
  }

  java.lang.String anyStringBut(EnumSet<TokenKind> skipToTokens) throws ParseException {
  java.lang.StringBuilder result = new StringBuilder();

  Token t = getToken(1);
  // next token is 1
  while(t.kind != EOF && !skipToTokens.contains(TokenKind.getFromTokenKind(t.kind))){
      t = getNextToken();
      // check next token
      result.append(t.image);
      t = getToken(1);
  }
    // The above loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
    // "if"/"while".
    return result.length() > 0 ? result.toString() : null;
  }

  void error_skipToNext(EnumSet<TokenKind> skipToTokens) throws ParseException {
  ParseException e = generateParseException();  // generate the exception object.
  System.out.println(e.toString());  // print the error message

  Token t = getToken(0);
  while(t.kind != EOF && !skipToTokens.contains(TokenKind.getFromTokenKind(t.kind))){
     // check next token
     t = getNextToken();
  }
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_3_2() {
    if (jj_scan_token(DASH)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(DASH)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public MitabLineParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[85];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x44000,0x44000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x44000,0x4000,0x4000,0x4000,0x4000,0x4000,0x4000,0x84000,0x4000,0x4000,0x4070,0x4070,0x4000,0x4000,0x200,0x200,0x80,0x401,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x4000,0x8,0x800,0x800,0x2000,0x800,0x800,0x800,0x800,0x800,0x800,0x10,0x800,0x800,0x800,0x100000,0x100000,0x4000,0x4000,0x4000,0x4000,0x400000,0x3c030,0x4000,0x70,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[2];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public MitabLineParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public MitabLineParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new MitabLineParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 85; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 85; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public MitabLineParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new MitabLineParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 85; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 85; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public MitabLineParser(MitabLineParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 85; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(MitabLineParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 85; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[23];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 85; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 23; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 2; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
