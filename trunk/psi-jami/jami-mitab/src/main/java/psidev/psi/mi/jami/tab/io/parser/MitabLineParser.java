/* Generated By:JavaCC: Do not edit this line. MitabLineParser.java */
package psidev.psi.mi.jami.tab.io.parser;

import psidev.psi.mi.jami.model.*;
import psidev.psi.mi.jami.binary.BinaryInteraction;
import psidev.psi.mi.jami.tab.extension.*;
import psidev.psi.mi.jami.tab.listener.MitabParserListener;
import java.util.Collection;
import java.util.Collections;
import psidev.psi.mi.jami.utils.CvTermUtils;
import psidev.psi.mi.jami.utils.PositionUtils;
import java.util.ArrayList;
import java.util.EnumSet;
import java.lang.NumberFormatException;
import psidev.psi.mi.jami.exception.IllegalParameterException;
import psidev.psi.mi.jami.exception.IllegalRangeException;
import psidev.psi.mi.jami.tab.utils.MitabUtils;

public abstract class MitabLineParser<T extends BinaryInteraction, P extends Participant> implements MitabLineParserConstants {

        void processSyntaxError(int lineNumber, int columnNumber, int mitabColumn, Exception e) {
            fireOnInvalidSyntax(lineNumber, columnNumber, mitabColumn, e);
        }

        public abstract MitabParserListener getParserListener();

        public abstract void setParserListener(MitabParserListener listener);

    abstract void fireOnInvalidSyntax(int lineNumber, int columnNumber, int mitabColumn, Exception e);

    abstract void reachEndOfFile();

    public abstract boolean hasFinished();

        abstract P finishParticipant(Collection<MitabXref> uniqueId, Collection<MitabXref> altid , Collection<MitabAlias> aliases,
                                               Collection<MitabOrganism> taxid, Collection<MitabCvTerm> bioRole, Collection<MitabCvTerm> expRole,
                                               Collection<MitabCvTerm> type, Collection<MitabXref> xref, Collection<MitabAnnotation> annot,
                                               Collection<MitabChecksum> checksum, Collection<MitabFeature> feature, Collection<MitabStoichiometry> stc,
                                               Collection<MitabCvTerm> detMethod, int line, int column, int mitabColumn);
        abstract T finishInteraction(P A, P B, Collection<MitabCvTerm> detMethod, Collection<MitabAuthor> firstAuthor,
                                               Collection<MitabXref> pubId, Collection<MitabCvTerm> interactionType, Collection<MitabSource> source,
                                               Collection<MitabXref> interactionId, Collection<MitabConfidence> conf, Collection<MitabCvTerm> expansion,
                                               Collection<MitabXref> xrefI, Collection<MitabAnnotation> annotI, Collection<MitabOrganism> host,
                                               Collection<MitabParameter> params, Collection<MitabDate> created, Collection<MitabDate> update,
                                               Collection<MitabChecksum> checksumI, boolean isNegative, int line);

  final public T MitabLine() throws ParseException {
  Collection<MitabXref> uniqueIdA;
  Collection<MitabXref> uniqueIdB;
  Collection<MitabXref> altIdA;
  Collection<MitabXref> altIdB;
  Collection<MitabAlias> aliasA;
  Collection<MitabAlias> aliasB;
  Collection<MitabCvTerm> detMethod;
  Collection<MitabAuthor> firstAuthor;
  Collection<MitabXref> pubId;
  Collection<MitabOrganism> taxidA;
  Collection<MitabOrganism> taxidB;
  Collection<MitabCvTerm> interactionType;
  Collection<MitabSource> source;
  Collection<MitabXref> interactionId;
  Collection<MitabConfidence> conf;
  Collection<MitabCvTerm> expansion = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> bioRoleA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> bioRoleB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> expRoleA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> expRoleB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> typeA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> typeB = Collections.EMPTY_LIST;
  Collection<MitabXref> xrefA = Collections.EMPTY_LIST;
  Collection<MitabXref> xrefB = Collections.EMPTY_LIST;
  Collection<MitabXref> xrefI = Collections.EMPTY_LIST;
  Collection<MitabAnnotation> annotA = Collections.EMPTY_LIST;
  Collection<MitabAnnotation> annotB = Collections.EMPTY_LIST;
  Collection<MitabAnnotation> annotI = Collections.EMPTY_LIST;
  Collection<MitabOrganism> host = Collections.EMPTY_LIST;
  Collection<MitabParameter> params = Collections.EMPTY_LIST;
  Collection<MitabDate> created = Collections.EMPTY_LIST;
  Collection<MitabDate> update = Collections.EMPTY_LIST;
  Collection<MitabChecksum> checksumA = Collections.EMPTY_LIST;
  Collection<MitabChecksum> checksumB = Collections.EMPTY_LIST;
  Collection<MitabChecksum> checksumI = Collections.EMPTY_LIST;
  boolean isNegative = false;
  Collection<MitabFeature> featureA = Collections.EMPTY_LIST;
  Collection<MitabFeature> featureB = Collections.EMPTY_LIST;
  Collection<MitabStoichiometry> stcA = Collections.EMPTY_LIST;
  Collection<MitabStoichiometry> stcB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> pmethodA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> pmethodB = Collections.EMPTY_LIST;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR);
  P participantA;
  P participantB;
  int line;
  int columnA;
  int columnB;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNRESERVED_STRING:
      case QUOTED_STRING:
      case EMPTY_COLUMN:
      case COMMENT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMENT:
          jj_consume_token(COMMENT);
          break;
        case UNRESERVED_STRING:
        case QUOTED_STRING:
        case EMPTY_COLUMN:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EMPTY_COLUMN:
            jj_consume_token(EMPTY_COLUMN);
                         uniqueIdA = Collections.EMPTY_LIST; line = token.beginLine; columnA = token.beginColumn;
            break;
          case UNRESERVED_STRING:
          case QUOTED_STRING:
            uniqueIdA = ids(CvTermUtils.createIdentityXrefQualifier(), false, 1);
            break;
          default:
            jj_la1[0] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                                                                                                                                                                                            line = token.beginLine; columnA = token.beginColumn;
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EMPTY_COLUMN:
            jj_consume_token(EMPTY_COLUMN);
                         uniqueIdB = Collections.EMPTY_LIST; columnB = token.beginColumn;
            break;
          case UNRESERVED_STRING:
          case QUOTED_STRING:
            uniqueIdB = ids(CvTermUtils.createIdentityXrefQualifier(), false, 2);
            break;
          default:
            jj_la1[1] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                                                                                                                                                                    columnB = token.beginColumn;
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EMPTY_COLUMN:
            jj_consume_token(EMPTY_COLUMN);
                         altIdA = Collections.EMPTY_LIST;
            break;
          case UNRESERVED_STRING:
          case QUOTED_STRING:
            altIdA = ids(CvTermUtils.createSecondaryXrefQualifier(), false, 3);
            break;
          default:
            jj_la1[2] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EMPTY_COLUMN:
            jj_consume_token(EMPTY_COLUMN);
                         altIdB = Collections.EMPTY_LIST;
            break;
          case UNRESERVED_STRING:
          case QUOTED_STRING:
            altIdB = ids(CvTermUtils.createSecondaryXrefQualifier(), false, 4);
            break;
          default:
            jj_la1[3] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EMPTY_COLUMN:
            jj_consume_token(EMPTY_COLUMN);
                         aliasA = Collections.EMPTY_LIST;
            break;
          case UNRESERVED_STRING:
          case QUOTED_STRING:
            aliasA = aliases(5);
            break;
          default:
            jj_la1[4] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EMPTY_COLUMN:
            jj_consume_token(EMPTY_COLUMN);
                         aliasB = Collections.EMPTY_LIST;
            break;
          case UNRESERVED_STRING:
          case QUOTED_STRING:
            aliasB = aliases(6);
            break;
          default:
            jj_la1[5] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EMPTY_COLUMN:
            jj_consume_token(EMPTY_COLUMN);
                         detMethod = Collections.EMPTY_LIST;
            break;
          case UNRESERVED_STRING:
          case QUOTED_STRING:
            detMethod = cvTerms(7);
            break;
          default:
            jj_la1[6] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EMPTY_COLUMN:
            jj_consume_token(EMPTY_COLUMN);
                         firstAuthor = Collections.EMPTY_LIST;
            break;
          case UNRESERVED_STRING:
          case QUOTED_STRING:
          case PUB_DATE:
            firstAuthor = firstAuthors();
            break;
          default:
            jj_la1[7] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EMPTY_COLUMN:
            jj_consume_token(EMPTY_COLUMN);
                         pubId = Collections.EMPTY_LIST;
            break;
          case UNRESERVED_STRING:
          case QUOTED_STRING:
            pubId = ids(CvTermUtils.createIdentityXrefQualifier(), true, 9);
            break;
          default:
            jj_la1[8] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EMPTY_COLUMN:
            jj_consume_token(EMPTY_COLUMN);
                         taxidA = Collections.EMPTY_LIST;
            break;
          case TAXID:
            taxidA = taxId(10);
            break;
          default:
            jj_la1[9] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EMPTY_COLUMN:
            jj_consume_token(EMPTY_COLUMN);
                         taxidB = Collections.EMPTY_LIST;
            break;
          case TAXID:
            taxidB = taxId(11);
            break;
          default:
            jj_la1[10] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EMPTY_COLUMN:
            jj_consume_token(EMPTY_COLUMN);
                         interactionType = Collections.EMPTY_LIST;
            break;
          case UNRESERVED_STRING:
          case QUOTED_STRING:
            interactionType = cvTerms(12);
            break;
          default:
            jj_la1[11] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EMPTY_COLUMN:
            jj_consume_token(EMPTY_COLUMN);
                         source = Collections.EMPTY_LIST;
            break;
          case UNRESERVED_STRING:
          case QUOTED_STRING:
            source = sourceDbs();
            break;
          default:
            jj_la1[12] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EMPTY_COLUMN:
            jj_consume_token(EMPTY_COLUMN);
                         interactionId = Collections.EMPTY_LIST;
            break;
          case UNRESERVED_STRING:
          case QUOTED_STRING:
            interactionId = ids(CvTermUtils.createIdentityXrefQualifier(), true, 14);
            break;
          default:
            jj_la1[13] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(COLUMN_SEPARATOR);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EMPTY_COLUMN:
            jj_consume_token(EMPTY_COLUMN);
                         conf = Collections.EMPTY_LIST;
            break;
          case UNRESERVED_STRING:
          case QUOTED_STRING:
            conf = confidences();
            break;
          default:
            jj_la1[14] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COLUMN_SEPARATOR:
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         expansion = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              expansion = complexExpansion();
              break;
            default:
              jj_la1[15] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         bioRoleA = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              bioRoleA = cvTerms(17);
              break;
            default:
              jj_la1[16] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         bioRoleB = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              bioRoleB = cvTerms(18);
              break;
            default:
              jj_la1[17] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         expRoleA = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              expRoleA = cvTerms(19);
              break;
            default:
              jj_la1[18] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         expRoleB = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              expRoleB = cvTerms(20);
              break;
            default:
              jj_la1[19] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         typeA = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              typeA = cvTerms(21);
              break;
            default:
              jj_la1[20] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         typeB = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              typeB = cvTerms(22);
              break;
            default:
              jj_la1[21] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         xrefA = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              xrefA = ids(null, false, 23);
              break;
            default:
              jj_la1[22] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         xrefB = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              xrefB = ids(null, false, 24);
              break;
            default:
              jj_la1[23] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         xrefI = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              xrefI = ids(null, false, 25);
              break;
            default:
              jj_la1[24] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         annotA = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              annotA = annotations(26);
              break;
            default:
              jj_la1[25] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         annotB = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              annotB = annotations(27);
              break;
            default:
              jj_la1[26] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         annotI = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              annotI = annotations(28);
              break;
            default:
              jj_la1[27] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         host = Collections.EMPTY_LIST;
              break;
            case TAXID:
              host = taxId(29);
              break;
            default:
              jj_la1[28] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         params = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              params = parameters();
              break;
            default:
              jj_la1[29] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         created = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              created = dates(31);
              break;
            default:
              jj_la1[30] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         update = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              update = dates(32);
              break;
            default:
              jj_la1[31] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         checksumA = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              checksumA = checksums(33);
              break;
            default:
              jj_la1[32] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         checksumB = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              checksumB = checksums(34);
              break;
            default:
              jj_la1[33] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
                         checksumI = Collections.EMPTY_LIST;
              break;
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              checksumI = checksums(35);
              break;
            default:
              jj_la1[34] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(COLUMN_SEPARATOR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EMPTY_COLUMN:
              jj_consume_token(EMPTY_COLUMN);
              break;
            case NEGATIVE:
              isNegative = negative();
              break;
            default:
              jj_la1[35] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COLUMN_SEPARATOR:
              jj_consume_token(COLUMN_SEPARATOR);
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case EMPTY_COLUMN:
                jj_consume_token(EMPTY_COLUMN);
                         featureA = Collections.EMPTY_LIST;
                break;
              case UNRESERVED_STRING:
              case QUOTED_STRING:
                featureA = features(37);
                break;
              default:
                jj_la1[36] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              jj_consume_token(COLUMN_SEPARATOR);
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case EMPTY_COLUMN:
                jj_consume_token(EMPTY_COLUMN);
                         featureB = Collections.EMPTY_LIST;
                break;
              case UNRESERVED_STRING:
              case QUOTED_STRING:
                featureB = features(38);
                break;
              default:
                jj_la1[37] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              jj_consume_token(COLUMN_SEPARATOR);
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case EMPTY_COLUMN:
                jj_consume_token(EMPTY_COLUMN);
                         stcA = Collections.EMPTY_LIST;
                break;
              case STOICHIOMETRY:
                stcA = stoichiometryList(39);
                break;
              default:
                jj_la1[38] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              jj_consume_token(COLUMN_SEPARATOR);
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case EMPTY_COLUMN:
                jj_consume_token(EMPTY_COLUMN);
                         stcB = Collections.EMPTY_LIST;
                break;
              case STOICHIOMETRY:
                stcB = stoichiometryList(40);
                break;
              default:
                jj_la1[39] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              jj_consume_token(COLUMN_SEPARATOR);
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case EMPTY_COLUMN:
                jj_consume_token(EMPTY_COLUMN);
                         pmethodA = Collections.EMPTY_LIST;
                break;
              case UNRESERVED_STRING:
              case QUOTED_STRING:
                pmethodA = cvTerms(41);
                break;
              default:
                jj_la1[40] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              jj_consume_token(COLUMN_SEPARATOR);
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case EMPTY_COLUMN:
                jj_consume_token(EMPTY_COLUMN);
                         pmethodB = Collections.EMPTY_LIST;
                break;
              case UNRESERVED_STRING:
              case QUOTED_STRING:
                pmethodB = cvTerms(42);
                break;
              default:
                jj_la1[41] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              jj_consume_token(COLUMN_SEPARATOR);
              break;
            default:
              jj_la1[42] = jj_gen;
              ;
            }
            break;
          default:
            jj_la1[43] = jj_gen;
            ;
          }
        participantA = finishParticipant(uniqueIdA, altIdA, aliasA, taxidA, bioRoleA, expRoleA, typeA, xrefA, annotA, checksumA, featureA, stcA, pmethodA, line, columnA, 1);
        participantB = finishParticipant(uniqueIdB, altIdB, aliasB, taxidB, bioRoleB, expRoleB, typeB, xrefB, annotB, checksumB, featureB, stcB, pmethodB, line, columnB, 2);
        {if (true) return finishInteraction(participantA, participantB, detMethod, firstAuthor, pubId, interactionType, source, interactionId,
                                 conf, expansion, xrefI, annotI, host, params, created, update, checksumI, isNegative, line);}
          break;
        default:
          jj_la1[44] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[45] = jj_gen;
        ;
      }
    } catch (ParseException e) {
        processSyntaxError(token.beginLine, token.beginColumn, 0, e);
        error_skipToNext(enumSet);
        {if (true) return null;}
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LINE_SEPARATOR:
      jj_consume_token(LINE_SEPARATOR);
      break;
    case 0:
      jj_consume_token(0);
                reachEndOfFile(); getParserListener().onEndOfFile();
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabXref> ids(CvTerm qualifier, boolean recognizeImex, int column) throws ParseException {
  Collection<MitabXref> xrefs;
  MitabXref var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = id(qualifier, recognizeImex, column);
          xrefs = new ArrayList<MitabXref>(); if (var != null) {xrefs.add(var);}
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[47] = jj_gen;
          break label_1;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = id(qualifier, recognizeImex, column);
                                                                   if (var != null) {xrefs.add(var);}
      }
     {if (true) return xrefs;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, column, e);
      error_skipToNext(enumSet);
       {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabAlias> aliases(int column) throws ParseException {
  Collection<MitabAlias> aliases;
  MitabAlias var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = alias(column);
     aliases = new ArrayList<MitabAlias>(); if (var != null) {if (var != null) {aliases.add(var);}}
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[48] = jj_gen;
          break label_2;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = alias(column);
                                            if (var != null) {if (var != null) {aliases.add(var);}}
      }
     {if (true) return aliases;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, column, e);
      error_skipToNext(enumSet);
       {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabCvTerm> cvTerms(int columnNumber) throws ParseException {
  Collection<MitabCvTerm> methods;
  MitabCvTerm var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = cvTerm(columnNumber);
     methods = new ArrayList<MitabCvTerm>(); if (var != null) {methods.add(var);}
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[49] = jj_gen;
          break label_3;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = cvTerm(columnNumber);
                                                   if (var != null) {methods.add(var);}
      }
     {if (true) return methods;}
    } catch (ParseException e) {
    processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
    error_skipToNext(enumSet);
     {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabAuthor> firstAuthors() throws ParseException {
  Collection<MitabAuthor> authors;
  MitabAuthor var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = author();
     authors = new ArrayList<MitabAuthor>(); if (var != null) {authors.add(var);}
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[50] = jj_gen;
          break label_4;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = author();
                                       if (var != null) {authors.add(var);}
      }
     {if (true) return authors;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, 8, e);
        error_skipToNext(enumSet);
        {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabOrganism> taxId(int column) throws ParseException {
  Collection<MitabOrganism> organisms;
  MitabOrganism var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = organism(column);
     organisms = new ArrayList<MitabOrganism>(); if (var != null) {organisms.add(var);}
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[51] = jj_gen;
          break label_5;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = organism(column);
                                               if (var != null) {organisms.add(var);}
      }
     {if (true) return organisms;}
    } catch (ParseException e) {
         processSyntaxError(token.beginLine, token.beginColumn, column, e);
         error_skipToNext(enumSet);
         {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabSource> sourceDbs() throws ParseException {
  Collection<MitabSource> sources;
  MitabSource var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = source();
     sources = new ArrayList<MitabSource>(); if (var != null) {sources.add(var);}
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[52] = jj_gen;
          break label_6;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = source();
                                       if (var != null) {sources.add(var);}
      }
     {if (true) return sources;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, 13, e);
       error_skipToNext(enumSet);
       {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabConfidence> confidences() throws ParseException {
  Collection<MitabConfidence> confs;
  MitabConfidence var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = confidence();
     confs = new ArrayList<MitabConfidence>(); if (var != null) {confs.add(var);}
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[53] = jj_gen;
          break label_7;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = confidence();
                                           if (var != null) {confs.add(var);}
      }
     {if (true) return confs;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, 15, e);
       error_skipToNext(enumSet);
       {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabCvTerm> complexExpansion() throws ParseException {
  Collection<MitabCvTerm> expansions;
  MitabCvTerm var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = expansion();
     expansions = new ArrayList<MitabCvTerm>(); if (var != null) {expansions.add(var);}
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[54] = jj_gen;
          break label_8;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = expansion();
                                          if (var != null) {expansions.add(var);}
      }
     {if (true) return expansions;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, 16, e);
     error_skipToNext(enumSet);
     {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabAnnotation> annotations(int column) throws ParseException {
  Collection<MitabAnnotation> annots;
  MitabAnnotation var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = annotation(column);
       annots = new ArrayList<MitabAnnotation>(); if (var != null) {annots.add(var);}
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[55] = jj_gen;
          break label_9;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = annotation(column);
                                                   if (var != null) {annots.add(var);}
      }
       {if (true) return annots;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, column, e);
      error_skipToNext(enumSet);
      {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabParameter> parameters() throws ParseException {
  Collection<MitabParameter> params;
  MitabParameter var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = parameter();
     params = new ArrayList<MitabParameter>(); if (var != null) {params.add(var);}
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[56] = jj_gen;
          break label_10;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = parameter();
                                          if (var != null) {params.add(var);}
      }
     {if (true) return params;}
    } catch (ParseException e) {
         processSyntaxError(token.beginLine, token.beginColumn, 30, e);
         error_skipToNext(enumSet);
         {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabDate> dates(int column) throws ParseException {
  Collection<MitabDate> dates;
  MitabDate var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = date(column);
       dates = new ArrayList<MitabDate>(); if (var != null) {if (var != null) {dates.add(var);}}
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[57] = jj_gen;
          break label_11;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = date(column);
                                             if (var != null) {if (var != null) {if (var != null) {dates.add(var);}}}
      }
       {if (true) return dates;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, column, e);
       error_skipToNext(enumSet);
       {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabChecksum> checksums(int column) throws ParseException {
  Collection<MitabChecksum> checksums;
  MitabChecksum var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = checksum(column);
       checksums = new ArrayList<MitabChecksum>(); if (var != null) {checksums.add(var);}
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[58] = jj_gen;
          break label_12;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = checksum(column);
                                                 if (var != null) {checksums.add(var);}
      }
       {if (true) return checksums;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, column, e);
     error_skipToNext(enumSet);
     {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabFeature> features(int column) throws ParseException {
  Collection<MitabFeature> features;
  MitabFeature var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = feature(column);
        features = new ArrayList<MitabFeature>(); if (var != null) {features.add(var);}
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[59] = jj_gen;
          break label_13;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = feature(column);
                                                 if (var != null) {features.add(var);}
      }
        {if (true) return features;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, column, e);
       error_skipToNext(enumSet);
       {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Collection<MitabStoichiometry> stoichiometryList(int column) throws ParseException {
  Collection<MitabStoichiometry> stc;
  MitabStoichiometry var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      var = stoichiometry(column);
     stc = new ArrayList<MitabStoichiometry>(); if (var != null) {stc.add(var);}
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD_SEPARATOR:
          ;
          break;
        default:
          jj_la1[60] = jj_gen;
          break label_14;
        }
        jj_consume_token(FIELD_SEPARATOR);
        var = stoichiometry(column);
                                                    if (var != null) {stc.add(var);}
      }
     {if (true) return stc;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, column, e);
     error_skipToNext(enumSet);
     {if (true) return Collections.EMPTY_LIST;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabStoichiometry stoichiometry(int columnNumber) throws ParseException {
  long min;
  java.lang.Long max = null;
  int beginLine;
  int beginColumn;
  MitabStoichiometry stc;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      jj_consume_token(STOICHIOMETRY);
        min = Long.parseLong(token.image.trim());
        beginLine = token.beginLine;
        beginColumn = token.beginColumn;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EMPTY_COLUMN:
        jj_consume_token(EMPTY_COLUMN);
        jj_consume_token(STOICHIOMETRY);
            max = Long.parseLong(token.image.trim());
        break;
      default:
        jj_la1[61] = jj_gen;
        ;
      }
         if (max != null){
            stc = new MitabStoichiometry(min, max);
         }
         else{
            stc = new MitabStoichiometry(min);
         }
         stc.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
         {if (true) return stc;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
        error_skipToNext(enumSet);
        {if (true) return null;}
    } catch (NumberFormatException e) {
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
       error_skipToNext(enumSet);
       {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabFeature feature(int columnNumber) throws ParseException {
  java.lang.String type;
  Collection<Range> ranges;
  Range var;
  java.lang.String text;
  MitabFeature feature;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //type:range1,range2(text)
          type = safeString();
                         beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(16);
      var = range(columnNumber);
     ranges = new ArrayList<Range>(); if (var != null) {ranges.add(var);}
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RANGE_SEPARATOR:
          ;
          break;
        default:
          jj_la1[62] = jj_gen;
          break label_15;
        }
        jj_consume_token(RANGE_SEPARATOR);
        var = range(columnNumber);
                                                  if (var != null) {ranges.add(var);}
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNRESERVED_STRING:
      case QUOTED_STRING:
        text = safeString();
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
      }
        feature = new MitabFeature(type);
        feature.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        feature.getRanges().addAll(ranges);

        {if (true) return feature;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet);
      {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabRange range(int columnNumber) throws ParseException {
  Position start;
  Position end;
  MitabRange range;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.RANGE_SEPARATOR, TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      jj_consume_token(POSITION);
      beginLine = token.beginLine; beginColumn = token.beginColumn;
      start = PositionUtils.createPositionFromString(token.image.trim());
      jj_consume_token(EMPTY_COLUMN);
      jj_consume_token(POSITION);
    end = PositionUtils.createPositionFromString(token.image.trim());
       range = new MitabRange(start, end);
        range.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       {if (true) return range;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet);
      {if (true) return null;}
    } catch (IllegalRangeException e) {
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
       error_skipToNext(enumSet);
       start = null;
    }
    throw new Error("Missing return statement in function");
  }

  final public boolean negative() throws ParseException {
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      jj_consume_token(NEGATIVE);
        {if (true) return Boolean.parseBoolean(token.image.trim());}
    } catch (ParseException e) {
    processSyntaxError(token.beginLine, token.beginColumn, 16, e);
     error_skipToNext(enumSet);
     {if (true) return false;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabChecksum checksum(int columnNumber) throws ParseException {
  java.lang.String method;
  java.lang.String value;
  MitabChecksum checksum;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //method:value
          method = safeString();
                           beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(16);
      value = safeString();
        checksum = new MitabChecksum(method, value);
        checksum.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        {if (true) return checksum;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
       error_skipToNext(enumSet);
        {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabDate date(int columnNumber) throws ParseException {
  java.lang.String date;
  MitabDate mitabDate;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //yyyy/mm/dd
          date = safeString();
      mitabDate = new MitabDate(date);
        mitabDate.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
        {if (true) return mitabDate;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
     error_skipToNext(enumSet);
      {if (true) return null;}
    } catch (java.text.ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
     error_skipToNext(enumSet);
     {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabParameter parameter() throws ParseException {
  java.lang.String type;
  java.lang.String value;
  java.lang.String unit = null;
  MitabParameter param;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //type:value(unit)
          type = safeString();
                         beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(16);
      value = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 17:
        jj_consume_token(17);
        unit = safeString();
        jj_consume_token(18);
        break;
      default:
        jj_la1[64] = jj_gen;
        ;
      }
     param = new MitabParameter(type, value, unit);
     param.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 30));
     {if (true) return param;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, 30, e);
       error_skipToNext(enumSet);
       {if (true) return null;}
    } catch (IllegalParameterException e) {
      processSyntaxError(token.beginLine, token.beginColumn, 30, e);
      error_skipToNext(enumSet);
      {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabAnnotation annotation(int columnNumber) throws ParseException {
  java.lang.String topic;
  java.lang.String value = null;
  MitabAnnotation annot;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //topic:value
          topic = safeString();
                          beginLine = token.beginLine; beginColumn = token.beginColumn;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 16:
        jj_consume_token(16);
        value = safeString();
        break;
      default:
        jj_la1[65] = jj_gen;
        ;
      }
      annot = new MitabAnnotation(topic, value);
      annot.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
      {if (true) return annot;}
    } catch (ParseException e) {
         processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
         error_skipToNext(enumSet);
         {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabXref xref(int columnNumber) throws ParseException {
  java.lang.String db;
  java.lang.String id;
  java.lang.String text = null;
  MitabXref ref;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //db:id(qualifier)
          db = safeString();
                       beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(16);
      id = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 17:
        jj_consume_token(17);
        text = safeString();
        jj_consume_token(18);
        break;
      default:
        jj_la1[66] = jj_gen;
        ;
      }
      ref = new MitabXref(db, id, text);
      ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
      {if (true) return ref;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
       error_skipToNext(enumSet);
       {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabCvTerm expansion() throws ParseException {
  java.lang.String db = null;
  java.lang.String id = null;
  java.lang.String name = null;
  MitabCvTerm cv;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //db:id(name) or just name for backward compatibility
          db = safeString();
                       beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(16);
      id = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 17:
        jj_consume_token(17);
        name = safeString();
        jj_consume_token(18);
        break;
      default:
        jj_la1[67] = jj_gen;
        ;
      }
      if (name == null){cv = new MitabCvTerm(MitabUtils.UNKNOWN_DATABASE, null, db, id);
           cv.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 16));
           getParserListener().onMissingCvTermName(cv, cv, "The complex expansion method does not have a name.");}
      else if (id == null) {cv = new MitabCvTerm(name);
            cv.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 16));
            getParserListener().onMissingExpansionId(cv);}
      else {cv = new MitabCvTerm(name, null, db, id); cv.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 16));}
      {if (true) return cv;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, 16, e);
     error_skipToNext(enumSet);
     {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabConfidence confidence() throws ParseException {
 java.lang.String type;
 java.lang.String value;
 java.lang.String text = null;
  MitabConfidence conf;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      type = safeString();
                         beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(16);
      value = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 17:
        jj_consume_token(17);
        text = safeString();
        jj_consume_token(18);
        break;
      default:
        jj_la1[68] = jj_gen;
        ;
      }
      if (text == null){conf = new MitabConfidence(type, value, null); conf.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 15));}
      else {conf = new MitabConfidence(type, value, text); conf.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 15));
             getParserListener().onTextFoundInConfidence(conf);}
      {if (true) return conf;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, 15, e);
     error_skipToNext(enumSet);
     {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabSource source() throws ParseException {
  java.lang.String db;
  java.lang.String id;
  java.lang.String name = null;
  MitabSource s;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //db:id(name)
             db = safeString();
                          beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(16);
      id = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 17:
        jj_consume_token(17);
        name = safeString();
        jj_consume_token(18);
        break;
      default:
        jj_la1[69] = jj_gen;
        ;
      }
         if (name == null){s = new MitabSource(MitabUtils.UNKNOWN_DATABASE, null, db, id); s.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 13));
            getParserListener().onMissingCvTermName(s, s, "The interaction source does not have a name.");}
         else {s = new MitabSource(name, null, db, id); s.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 13));}
         {if (true) return s;}
    } catch (ParseException e) {
        processSyntaxError(token.beginLine, token.beginColumn, 13, e);
        error_skipToNext(enumSet);
        {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabOrganism organism(int columnNumber) throws ParseException {
  java.lang.String id;
  java.lang.String name = null;
  MitabOrganism organism;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      jj_consume_token(TAXID);
      jj_consume_token(16);
      id = safeString();
                                   beginLine = token.beginLine; beginColumn = token.beginColumn;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 17:
        jj_consume_token(17);
        name = safeString();
        jj_consume_token(18);
        break;
      default:
        jj_la1[70] = jj_gen;
        ;
      }
       organism = new MitabOrganism(Integer.parseInt(id), name);
       organism.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       {if (true) return organism;}
    } catch (ParseException e) {
           processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
           error_skipToNext(enumSet);
           {if (true) return null;}
    } catch (NumberFormatException e) {
           processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
           error_skipToNext(enumSet);
           {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabAuthor author() throws ParseException {
 MitabAuthor auth;
 java.lang.String first=null;
 java.lang.String date = null;
 java.lang.String second;
 int beginLine;
 int beginColumn;
 EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PUB_DATE:
        jj_consume_token(PUB_DATE);
                    date = token.image.trim(); beginLine = token.beginLine; beginColumn = token.beginColumn;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case UNRESERVED_STRING:
        case QUOTED_STRING:
          first = safeString();
          break;
        default:
          jj_la1[71] = jj_gen;
          ;
        }
        break;
      case UNRESERVED_STRING:
      case QUOTED_STRING:
        first = safeString();
                               beginLine = token.beginLine; beginColumn = token.beginColumn;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PUB_DATE:
        case 17:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PUB_DATE:
            jj_consume_token(PUB_DATE);
                                                                                                               date = token.image.trim();
            break;
          case 17:
            jj_consume_token(17);
            jj_consume_token(PUB_DATE);
                                                                                                                                                               date = token.image.trim();
            jj_consume_token(18);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case UNRESERVED_STRING:
            case QUOTED_STRING:
              second = safeString();
                                                                                                                                                                                                                         first = first + " " +second;
              break;
            default:
              jj_la1[72] = jj_gen;
              ;
            }
            break;
          default:
            jj_la1[73] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[74] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[75] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
       beginLine = token.beginLine; beginColumn = token.beginColumn;
       if (date == null){auth = new MitabAuthor(first);}
       else{ auth = new MitabAuthor(first, date);}
       auth.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 8));
       {if (true) return auth;}
    } catch (ParseException e) {
       processSyntaxError(token.beginLine, token.beginColumn, 8, e);
       error_skipToNext(enumSet);
       {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabCvTerm cvTerm(int column) throws ParseException {
  java.lang.String db;
  java.lang.String id = null;
  java.lang.String name = null;
  int beginLine;
  int beginColumn;
  MitabCvTerm cv;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      db = safeString();
                       beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(16);
      id = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 17:
        jj_consume_token(17);
        name = safeString();
        jj_consume_token(18);
        break;
      default:
        jj_la1[76] = jj_gen;
        ;
      }
      if (name == null){cv = new MitabCvTerm(MitabUtils.UNKNOWN_DATABASE, null, db, id); cv.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, column));
          getParserListener().onMissingCvTermName(cv, cv, "The term at the column " + column + " does not have a name.");}
      else {cv = new MitabCvTerm(name, null, db, id); cv.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, column));}
      {if (true) return cv;}
    } catch (ParseException e) {
     processSyntaxError(token.beginLine, token.beginColumn, column, e);
     error_skipToNext(enumSet);
     {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabAlias alias(int columnNumber) throws ParseException {
  java.lang.String db;
  java.lang.String name;
  java.lang.String type = null;
  int beginLine;
  int beginColumn;
  MitabAlias alias;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      db = safeString();
                         beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(16);
      name = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 17:
        jj_consume_token(17);
        type = safeString();
        jj_consume_token(18);
        break;
      default:
        jj_la1[77] = jj_gen;
        ;
      }
        alias = new MitabAlias(db, name, type);
        alias.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        {if (true) return alias;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet);
      {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public MitabXref id(CvTerm qualifier, boolean recognizeImexPrimary, int columnNumber) throws ParseException {
  java.lang.String db;
  java.lang.String id;
  java.lang.String text = null;
  int beginLine;
  int beginColumn;
  MitabXref ref;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
    try {
      //db:id(qualifier)
          db = safeString();
                       beginLine = token.beginLine; beginColumn = token.beginColumn;
      jj_consume_token(16);
      id = safeString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 17:
        jj_consume_token(17);
        text = safeString();
        jj_consume_token(18);
        break;
      default:
        jj_la1[78] = jj_gen;
        ;
      }
      if (recognizeImexPrimary && Xref.IMEX.equalsIgnoreCase(db.trim())){
         if (text == null){ref = new MitabXref(db, id, CvTermUtils.createImexPrimaryQualifier()); ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));}
         else if (qualifier != null) {ref = new MitabXref(db, id, text);
         ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
         getParserListener().onTextFoundInIdentifier(ref);}
         else {ref = new MitabXref(db, id, text); ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));}
       }
       else if (text == null) {
         ref = new MitabXref(db, id, qualifier);
         ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       }
       else if (qualifier != null) {
          ref = new MitabXref(db, id, text);
          ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
          getParserListener().onTextFoundInIdentifier(ref);
       }
       else{
          ref = new MitabXref(db, id, text);
          ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       }
       {if (true) return ref;}
    } catch (ParseException e) {
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet);
      {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public java.lang.String safeString() throws ParseException {
 java.lang.String text;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_STRING:
      jj_consume_token(QUOTED_STRING);
                    text = MitabUtils.unescapeDoubleQuote(token.image.substring(1, token.image.length()).trim());
      break;
    case UNRESERVED_STRING:
      jj_consume_token(UNRESERVED_STRING);
                                                                                                                                          text = token.image.trim();
      break;
    default:
      jj_la1[79] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
   {if (true) return text;}
    throw new Error("Missing return statement in function");
  }

  void error_skipToNext(EnumSet<TokenKind> skipToTokens) throws ParseException {
  ParseException e = generateParseException();  // generate the exception object.
  System.out.println(e.toString());  // print the error message

  Token t;
  // next token is 1
  int i = 1;
  do {
    t = getNextToken();
    // check next token
    i++;
    t = getToken(i);
  } while (t.kind != EOF && !skipToTokens.contains(TokenKind.getFromTokenKind(t.kind)));
  }

  /** Generated Token Manager. */
  public MitabLineParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[80];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x70,0x70,0x70,0x70,0x70,0x70,0x70,0xf0,0x70,0x140,0x140,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x140,0x70,0x70,0x70,0x70,0x70,0x70,0x240,0x70,0x70,0x840,0x840,0x70,0x70,0x4000,0x4000,0x1070,0x1070,0x8001,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x40,0x8,0x30,0x20000,0x10000,0x20000,0x20000,0x20000,0x20000,0x20000,0x30,0x30,0x20080,0x20080,0xb0,0x20000,0x20000,0x20000,0x30,};
   }

  /** Constructor with InputStream. */
  public MitabLineParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public MitabLineParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new MitabLineParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 80; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 80; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public MitabLineParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new MitabLineParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 80; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 80; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public MitabLineParser(MitabLineParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 80; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(MitabLineParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 80; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[19];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 80; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 19; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
