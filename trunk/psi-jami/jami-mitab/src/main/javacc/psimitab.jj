
options {
  LOOKAHEAD = 1;
  FORCE_LA_CHECK = true;
  JAVA_UNICODE_ESCAPE = true;
  STATIC = false;
}

PARSER_BEGIN(MitabLineParser)

import psidev.psi.mi.jami.model.*;
import psidev.psi.mi.jami.mitab.extension.*;
import java.util.Collection;
import java.util.Collections;
import psidev.psi.mi.jami.utils.CvTermUtils;
import psidev.psi.mi.jami.utils.PositionUtils;
import psidev.psi.mi.jami.utils.XrefUtils;
import psidev.psi.mi.jami.utils.RangeUtils;
import psidev.psi.mi.jami.mitab.listener.MitabParserListener;
import java.util.ArrayList;
import java.lang.NumberFormatException;
import java.util.Date;
import java.text.ParseException;
import psidev.psi.mi.jami.exception.IllegalParameterException;
import psidev.psi.mi.jami.exception.IllegalRangeException

public class MitabLineParser {

	void skipTo(int tokenKind) {
		Token t;
		do {
			t = getNextToken();
		} while (t.kind != tokenKind);
	}
	
	void logSyntaxError(ParseException e) {
	}

	abstract Participant finishParticipant(UniqueId, );

	MitabParserListener getParserListener();

	void setParserListener(MitabParserListener listener);
}

PARSER_END(MitabLineParser)

/* WHITE SPACE */

SKIP :
{
  "\r" | "\f"
}

TOKEN :
{
  < UNRESERVED_STRING:
    //don't match single dash, that's an empty column
      "-" (~["\"", "|", "(", ")", ":", "\t", "\n", "-"])+
    |
      ~["\"", "|", "(", ")", ":", "\t", "\n", "-"] (~["\"", "|", "(", ")", ":", "\t", "\n"])*
    >
 |
  < QUOTED_STRING:
    "\"" 
      ( ~["\""] | ("\\" "\"") )* 
    "\""
    >
 |
  < EMPTY_COLUMN: "-" >
}

TOKEN :
{
  < PUB_DATE: (["0"-"9"]){4} >
}

TOKEN [IGNORE_CASE]:
{
 <TAXID : "taxid">
}

TOKEN [IGNORE_CASE]:
{
 <NEGATIVE : (" ")* ("true" | "false" | ("\"" "true" | "false" "\"")) (" ")* >
}

TOKEN [IGNORE_CASE]:
{
 <POSITION : (" ")* ("n" | "c" | "<" | ">" | "?" |  ["-"] (["0"-"9"])+ (" ")* >
}

TOKEN :
{
  < STOICHIOMETRY: (["0"-"9"])+ ["." (["0"-"9"])+ ] >
}

TOKEN :
{
  < COMMENT: "#" (~["\n"])*>
}

boolean MitabLine():
{
  boolean isFinished = false;
  Collection<MitabXref> uniqueIdA;
  Collection<MitabXref> uniqueIdB;
  Collection<MitabXref> altIdA;
  Collection<MitabXref> altIdB;
  Collection<MitabAlias> aliasA;
  Collection<MitabAlias> aliasB;
  Collection<MitabCvTerm> detMethod;
  Collection<MitabAuthor> firstAuthor;
  Collection<MitabXref> pubId;
  Collection<MitabOrganism> taxidA;
  Collection<MitabOrganism> taxidB;
  Collection<MitabCvTerm> interactionType;
  Collection<MitabSource> source;
  Collection<MitabXref> interactionId;
  Collection<MitabConfidence> conf;
  Collection<MitabCvTerm> expansion;
  Collection<MitabCvTerm> bioRoleA;
  Collection<MitabCvTerm> bioRoleB;
  Collection<MitabCvTerm> expRoleA;
  Collection<MitabCvTerm> expRoleB;
  Collection<MitabCvTerm> typeA;
  Collection<MitabCvTerm> typeB;
  Collection<MitabXref> xrefA;
  Collection<MitabXref> xrefB;
  Collection<MitabXref> xrefI;
  Collection<MitabAnnotation> annotA;
  Collection<MitabAnnotation> annotB;
  Collection<MitabAnnotation> annotI;
  Collection<MitabOrganism> host;
  Collection<MitabParameter> params;
  Collection<MitabDate> created;
  Collection<MitabDate> update;
  Collection<MitabAnnotation> checksumA;
  Collection<MitabAnnotation> checksumB;
  Collection<MitabAnnotation> checksumI;
  boolean isNegative = false;
  Collection<MitabFeature> featureA;
  Collection<MitabFeature> featureB;
  Collection<MitabCvTerm> pmethodA;
  Collection<MitabCvTerm> pmethodB;
}
{
(
  //allow empty lines
  [
    ( <COMMENT> )
  |
    (
      (<EMPTY_COLUMN> {uniqueIdA = Collections.EMPTY_LIST;} | uniqueIdA = uniqueId(1)) "\t"
      (<EMPTY_COLUMN> {uniqueIdB = Collections.EMPTY_LIST;} | uniqueIdB = uniqueId(2)) "\t"
      (<EMPTY_COLUMN> {altidA = Collections.EMPTY_LIST;} | altIdA = altIds(3)) "\t"
      (<EMPTY_COLUMN> {altidB = Collections.EMPTY_LIST;} | altIdB = altIds(4)) "\t"
      (<EMPTY_COLUMN> {aliasA = Collections.EMPTY_LIST;} | aliasA = aliases(5)) "\t"
      (<EMPTY_COLUMN> {aliasB = Collections.EMPTY_LIST;} | aliasB = aliases(6)) "\t"
      (<EMPTY_COLUMN> {detMethod = Collections.EMPTY_LIST;} | detMethod = cvTerms(7)) "\t"
      (<EMPTY_COLUMN> {firstAuthor = Collections.EMPTY_LIST;} | firstAuthor = firstAuthors()) "\t"
      (<EMPTY_COLUMN> {pubId = Collections.EMPTY_LIST;} | pubId = publicationId()) "\t"
      (<EMPTY_COLUMN> {taxidA = Collections.EMPTY_LIST;} | taxidA = taxId(10)) "\t"
      (<EMPTY_COLUMN> {taxidB = Collections.EMPTY_LIST;} | taxidB = taxId(11)) "\t"
      (<EMPTY_COLUMN> {interactionType = Collections.EMPTY_LIST;} | interactionType = cvTerms(12)) "\t"
      (<EMPTY_COLUMN> {source = Collections.EMPTY_LIST;} | source = sourceDbs()) "\t"
      (<EMPTY_COLUMN> {interactionId = Collections.EMPTY_LIST;} | interactionId = interactionIds()) "\t"
      (<EMPTY_COLUMN> {conf = Collections.EMPTY_LIST;} | conf = confidences())
      
      [ //starting MITAB 2.6
      "\t" //end of confidences delimiter
      (<EMPTY_COLUMN> {expansion = Collections.EMPTY_LIST;} | expansion = complexExpansion()) "\t"
      (<EMPTY_COLUMN> {bioRoleA = Collections.EMPTY_LIST;} | bioRoleA = cvTerms(17)) "\t"
      (<EMPTY_COLUMN> {bioRoleB = Collections.EMPTY_LIST;} | bioRoleB = cvTerms(18)) "\t"
      (<EMPTY_COLUMN> {expRoleA = Collections.EMPTY_LIST;} | expRoleA = cvTermsv(19)) "\t"
      (<EMPTY_COLUMN> {expRoleB = Collections.EMPTY_LIST;} | expRoleB = cvTerms(20)) "\t"
      (<EMPTY_COLUMN> {typeA = Collections.EMPTY_LIST;} | typeA = cvTerms(21)) "\t"
      (<EMPTY_COLUMN> {typeB = Collections.EMPTY_LIST;} | typeB = cvTerms(22)) "\t"
      (<EMPTY_COLUMN> {xrefA = Collections.EMPTY_LIST;} | xrefA = xrefs(23)) "\t"
      (<EMPTY_COLUMN> {xrefB = Collections.EMPTY_LIST;} | xrefB = xrefs(24)) "\t"
      (<EMPTY_COLUMN> {xrefI = Collections.EMPTY_LIST;} | xrefI = xrefs(25)) "\t"
      (<EMPTY_COLUMN> {annotA = Collections.EMPTY_LIST;} | annotA = annotations(26)) "\t"
      (<EMPTY_COLUMN> {annotB = Collections.EMPTY_LIST;} | annotB = annotations(27)) "\t"
      (<EMPTY_COLUMN> {annotI = Collections.EMPTY_LIST;} | annotI = annotations(28)) "\t"
      (<EMPTY_COLUMN> {host = Collections.EMPTY_LIST;} | host = taxId(29)) "\t"
      (<EMPTY_COLUMN> {params = Collections.EMPTY_LIST;} | params = parameters()) "\t"
      (<EMPTY_COLUMN> {created = Collections.EMPTY_LIST;} | created = dates(31)) "\t"
      (<EMPTY_COLUMN> {update = Collections.EMPTY_LIST;} | update = dates(32)) "\t"
      (<EMPTY_COLUMN> {checksumA = Collections.EMPTY_LIST;} | checksumA = checksums(33)) "\t"
      (<EMPTY_COLUMN> {checksumB = Collections.EMPTY_LIST;} | checksumB = checksums(34)) "\t"
      (<EMPTY_COLUMN> {checksumI = Collections.EMPTY_LIST;} | checksumI = checksums(35)) "\t"
      (<EMPTY_COLUMN> | negative = negative())
      
      [ //starting MITAB 2.7
      "\t" //end of negative() delimiter
      (<EMPTY_COLUMN> {featureA = Collections.EMPTY_LIST;} | featureA = features(37)) "\t"
      (<EMPTY_COLUMN> {featureB = Collections.EMPTY_LIST;} | featureB = features(38)) "\t"
      (<EMPTY_COLUMN> | stoichiometry()) "\t"
      (<EMPTY_COLUMN> | stoichiometry()) "\t"
      (<EMPTY_COLUMN> {pmethodA = Collections.EMPTY_LIST;} | pmethodA = cvTermsv(41)) "\t"
      (<EMPTY_COLUMN> {pmethodB = Collections.EMPTY_LIST;} | pmethodB = cvTermsv(42)) "\t"
      ] // end MITAB 2.7
      
      ] //end MITAB 2.6
    )
    {
      participantA = finishParticipant(idA, altIdA, ...);
      participantB = finishParticipant(idB, altIdB, ...);
      return finishInteraction(participantA, partcipantB, etc); 
    }
  ]
    
  //line/file termination
  ( 
      "\n" 
    | 
      (<EOF> {isFinished = true;})
  )
)
  { return isFinished; }
}

Collection<MitabXref> uniqueId(int column):
{
  Collection<MitabXref> xrefs;
  MitabXref var;
}
{
  var = id(CvTermUtils.createIdentityXrefQualifier(), column)
  {xrefs = new ArrayList<MitabXref>(); xrefs.add(var);}

  ("|" var = id(CvTermUtils.createIdentityXrefQualifier(), column) {xrefs.add(var);})*
  {return xrefs;}
}

Collection<MitabXref> altIds(int column):
{
  Collection<MitabXref> xrefs;
  MitabXref var;
}
{
  var = id(CvTermUtils.createSecondaryXrefQualifier(), column)
  {xrefs = new ArrayList<MitabXref>(); xrefs.add(var);}

  ("|" var = id(CvTermUtils.createSecondaryXrefQualifier(), column) {xrefs.add(var);})*
  {return xrefs;}
}

Collection<MitabAlias> aliases(int column):
{
  Collection<MitabAlias> aliases;
  MitabAlias var;
}
{
  var = alias(column)
  {aliases = new ArrayList<MitabAlias>(); aliases.add(var);}

  ("|" var = alias(column) {aliases.add(var);})*
  {return aliases;}
}

Collection<MitabCvterm> cvTerms(int columnNumber):
{
  Collection<MitabCvterm> methods;
  MitabCvTerm var;
}
{
  var = cvTerm(columnNumber)
  {methods = new ArrayList<MitabCvterm>(); methods.add(var);}

  ("|" var = cvTerm(columnNumber) {methods.add(var);})*
  {return methods;}
}

Collection<MitabAuthor> firstAuthors():
{
  Collection<MitabAuthor> authors;
  MitabAuthor var;
}
{
  var = author()
  {authors = new ArrayList<MitabAuthor>(); authors.add(var);}

  ("|" var = author() {authors.add(var);})*
  {return authors;}
}

Collection<MitabXref> publicationId():
{
  Collection<MitabXref> refs;
  MitabXref var;
}
{
  var = idWithImex(9)
  {refs = new ArrayList<MitabXref>(); refs.add(var);}

  ("|" var = idWithImex(9) {refs.add(var);})*
  {return refs;}
}

Collection<MitabOrganism> taxId(int column):
{
  Collection<MitabOrganism> organisms;
  MitabOrganism var;
}
{
  var = organism(column)
  {organisms = new ArrayList<MitabOrganism>(); organisms.add(var);}

  ("|" var = organism(column) {organisms.add(var);})*
  {return organisms;}
}

Collection<MitabSource> sourceDbs():
{
  Collection<MitabSource> sources;
  MitabSource var;
}
{
  var = source()
  {sources = new ArrayList<MitabSource>(); sources.add(var);}

  ("|" var = source() {sources.add(var);})*
  {return sources;}
}

Collection<MitabXref> interactionIds():
{
  Collection<MitabXref> refs;
  MitabXref var;
}
{
  var = idWithImex(14)
  {refs = new ArrayList<MitabXref>(); refs.add(var);}

  ("|" var = idWithImex(14) {refs.add(var);})*
  {return refs;}
}

Collection<MitabConfidence> confidences():
{
  Collection<MitabConfidence> confs;
  MitabConfidence var;
}
{
  var = confidence()
  {confs = new ArrayList<MitabConfidence>(); confs.add(var);}

  ("|" var = confidence() {confs.add(var);})*
  {return confs;}
}

Collection<MitabCvTerm> complexExpansion():
{
  Collection<MitabCvterm> expansions;
  MitabCvTerm var;
}
{
  var = expansion()
  {expansions = new ArrayList<MitabCvterm>(); expansions.add(var);}

  ("|" var = expansion() {expansions.add(var);})*
  {return expansions;}
}

Collection<MitabXref> xrefs(int column):
{
  Collection<MitabXref> refs;
  MitabXref var;
}
{
  var = xref(column)
  {refs = new ArrayList<MitabXref>(); refs.add(var);}

  ("|" var = xref(column) {refs.add(var);})*
  {return refs;}
}

Collection<MitabAnnotation> annotations(int column):
{
  Collection<MitabAnnotation> annots;
  MitabAnnotation var;
}
{
  var = annotation(column)
  {annots = new ArrayList<MitabAnnotation>(); annots.add(var);}

  ("|" var = annotation(column) {annots.add(var);})*
  {return annots;}
}

Collection<MitabParameter> parameters() throws ParseException:
{
  Collection<MitabParameter> params;
  MitabParameter var;
}
{
  var = parameter(column)
  {params = new ArrayList<MitabParameter>(); params.add(var);}

  ("|" var = parameter(column) {params.add(var);})*
  {return params;}
}

Collection<MitabDate> dates(int column) throws ParseException:
{
  Collection<MitabDate> dates;
  MitabDate var;
}
{
  var = date(column)
  {dates = new ArrayList<MitabDate>(); dates.add(var);}

  ("|" var = date(column) {dates.add(var);})*
  {return dates;}
}

Collection<MitabChecksum> checksums(int column):
{
  Collection<MitabChecksum> checksums;
  MitabChecksum var;
}
{
  var = checksum(column)
  {checksums = new ArrayList<MitabChecksum>(); checksums.add(var);}

  ("|" var = checksum(column) {checksums.add(var);})*
  {return checksums;}
}

Collection<MitabFeature> features(int column):
{
  Collection<MitabFeature> features;
  MitabFeature var;
}
{
  var = feature(column)
  {features = new ArrayList<MitabFeature>(); features.add(var);}

  ("|" var = feature(column) {features.add(var);})*
  {return features;}
}

Stoichiometry stoichiometry():
{
  java.lang.String min;
  java.lang.String max = null;
}
{
  //float
  <STOICHIOMETRY>
  {
      return Boolean.parseBoolean(token.image.trim());
    }
}

MitabFeature feature(int columnNumber):
{
  java.lang.String type;
  Collection<Range> ranges;
  Range var;
  java.lang.String text;
  MitabFeature feature;
}
{
  //type:range1,range2(text)
  type = safeString() ":" var = range(columnNumber) {ranges = new ArrayList<Range>(); ranges.add(var);}
  ("," var = range(columnNumber) {ranges.add(var);})* [ text = safeString() ]
  {
      feature = new MitabFeature(type);
      feature.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
      feature.addAll(ranges);

      return feature;
    }
}

MitabRange range(int columnNumber) throws ParseException:
{
  Position start;
  Position end;
  MitabRange range;
}
{
  //x-x
  <POSITION>
  {try{
      start = PositionUtils.createPositionFromString(token.image.trim());
      start.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
      } catch(IllegalRangeException e){
          throws new ParseException("The start " + token + " is not a valid start position.");
      }
  }
  "-" <POSITION>
  {
  try{
        end = PositionUtils.createPositionFromString(token.image.trim());
        start.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
        } catch(IllegalRangeException e){
            throws new ParseException("The end " + token + " is not a valid end position.");
        }

      range = new MitabRange(start, end);
      range.setSourceLocator(start.getSourceLocator());
      return range;
    }
}

boolean negative():
{
  boolean isNegative;
}
{
  //method:value
  <NEGATIVE>
  {
      return Boolean.parseBoolean(token.image.trim());
    }
}

MitabChecksum checksum(int columnNumber):
{
  java.lang.String method;
  java.lang.String value;
  MitabChecksum checksum;
}
{
  //method:value
  method = safeString() ":" value = safeString()
  {
      method = new MitabChecksum(method, value);
      method.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
      return checksum;
    }
}

MitabDate date(int columnNumber) throws ParseException:
{
  java.lang.String date;
  MitabDate mitabDate;
}
{
  //yyyy/mm/dd
  date = safeString()
  { try{
      mitabDate = new MitabDate(date);
      mitabDate.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
      return mitabDate;}
  } catch (java.text.ParseException e){
      throws new ParseException("The date " + date + " is not well formated. We expect yyyy/mm/dd",e);
  }
}

MitabAnnotation parameter() throws ParseException:
{
  java.lang.String type;
  java.lang.String value;
  java.lang.String unit = null;
  MitabParameter param;
}
{
  //type:value(unit)
  type = safeString() ":" value = safeString() [ "(" unit = safeString() ")" ]
  { try{
      param = new MitabParameter(type, value, unit);
      param.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, 30));
      return param;
  } catch (IllegalParameterException e){
     throws new ParseException("The parameter " + value + " is not well formated.",e);
  }
    }
}

MitabAnnotation annotation(int columnNumber):
{
  java.lang.String topic;
  java.lang.String value = null;
  MitabAnnotation annot;
}
{
  //topic:value
  topic = safeString() [ ":" value = safeString() ]
  { annot = new MitabAnnotation(topic, value);
    annot.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
    return annot;}
}

MitabXref xref(int columnNumber):
{
  java.lang.String db;
  java.lang.String id;
  java.lang.String text = null;
  MitabXref ref;
}
{
  //db:id(qualifier)
  db = safeString() ":" id = safeString() [ "(" text = safeString() ")" ]
  { ref = new MitabXref(db, id, text);
    ref.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
    return ref;}
}

MitabCvTerm expansion():
{
  java.lang.String db = null;
  java.lang.String id = null;
  java.lang.String name = null;
  MitabCvTerm cv;
}
{
  //db:id(name)
  db = safeString() ":" id = safeString() [ "(" name = safeString() ")" ]
  | name = safeString()
  { if (name == null){cv = new MitabCvTerm(MitabWriterUtils.UNKNOWN_DATABASE, null, db, id); getParserListener().onMissingCvTermName(token.beginLine, token.beginColumn, 16);}
    else if (id == null) {cv = new MitabCvTerm(name); getParserListener().onMissingExpansionId(token.beginLine, token.beginColumn, 16);}
    else {cv = new MitabCvTerm(name, null, db, id);}
    cv.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, 16));
    return cv;}
}

MitabConfidence confidence():
{
 java.lang.String type;
 java.lang.String value;
 java.lang.String test = null;
  MitabConfidence conf;
}
{
  type = safeString() ":" value = safeString() [ "(" text = safeString() ")" ]
  { if (text == null){conf = new MitabConfidence(type, value, null);}
    else {conf = new MitabConfidence(type, value, text); getParserListener().onTextFoundInConfidence(token.beginLine, token.beginColumn, 15);}
    conf.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, 15));
    return conf;}
}

MitabSource source():
{
  java.lang.String db;
  java.lang.String id;
  java.lang.String name = null;
  MitabSource s;
}
{
  //db:id(name)
  db = safeString() ":" id = safeString() [ "(" name = safeString() ")" ]
  { if (name == null){s = new MitabCvTerm(MitabWriterUtils.UNKNOWN_DATABASE, null, db, id); getParserListener().onMissingCvTermName(token.beginLine, token.beginColumn, 13);}
    else {s = new MitabSource(name, null, db, id);}
    s.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, 13));
    return s;}
}

MitabOrganism organism(int columnNumber) throws ParseException:
{
  java.lang.String id;
  java.lang.String name = null;
  MitabOrganism organism;
}
{
  //taxid:id(name)
  [(" ")*] <TAXID> ":" id = safeString() [ "(" name = safeString() ")" ]
  {
    try {
        organism = new MitabOrganism(Integer.parseInt(id), name);
        organism.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
        return organism;
    }
    catch (NumberFormatException e){
       throws new ParseException("The taxid id is not a valid integer.", e);
    }
    }
}

MitabXref idWithImex(int columnNumber):
{
  java.lang.String db;
  java.lang.String id;
  java.lang.String text = null;
  MitabXref ref;
}
{
  //db:id(qualifier)
  db = safeString() ":" id = safeString() [ "(" text = safeString() ")" ]
  { if (Xref.IMEX.equalsIgnoreCase(db.trim())){
        if (text == null){ref = new MitabXref(db, id, CvTermUtils.createImexPrimaryQualifier());}
        else {ref = new MitabXref(db, id, text); getParserListener().onTextFoundInIdentifier(token.beginLine, token.beginColumn, columnNumber);}
    }
    else{
        if (text == null){ref = new MitabXref(db, id, CvTermUtils.createIdentityXrefQualifier());}
        else {ref = new MitabXref(db, id, text); getParserListener().onTextFoundInIdentifier(token.beginLine, token.beginColumn, columnNumber);}
    }
    ref.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
    return ref;}
}

MitabAuthor author():
{
 MitabAuthor auth;
 java.lang.String first;
 java.lang.String date;
 java.lang.String second;
}
{
  ( <PUB_DATE> {date = token.image;} [ first = safeString() ])
   | ( first = safeString() [ ( <PUB_DATE> {date = token.image;} [ second = safeString() {first = first + " " +second} ]) ])
   | ( first = safeString() [ ( "(" (" ")* <PUB_DATE> {date = token.image;} (" ")* ")" [ second = safeString() {first = first + " " +second} ]) ])
   | first = safeString()
   { if (date == null){auth = new MitabAuthor(first);}
     else{ auth = new MitabAuthor(first, date);}
     auth.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, 8));
     return auth;
    }
}

MitabCvTerm cvTerm(int column):
{
  java.lang.String db;
  java.lang.String id;
  java.lang.String name = null;
  MitabCvTerm cv;
}
{
  //db:id(name)
  db = safeString() ":" id = safeString() [ "(" name = safeString() ")" ]
  { if (name == null){cv = new MitabCvTerm(MitabWriterUtils.UNKNOWN_DATABASE, null, db, id); getParserListener().onMissingCvTermName(token.beginLine, token.beginColumn, column);}
    else {cv = new MitabCvTerm(name, null, db, id);}
    cv.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
    return cv;}
}

MitabAlias alias(int columnNumber):
{
  java.lang.String db;
  java.lang.String name;
  java.lang.String type = null;
  MitabAlias alias;
}
{
  //db:name(type)
  db = safeString() ":" name = safeString() [ "(" type = safeString() ")" ]
  { alias = new MitabAlias(db, name, type);
    alias.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
    return alias;}
}

MitabXref id(CvTerm qualifier, int columnNumber):
{
  java.lang.String db;
  java.lang.String id;
  java.lang.String text = null;
  MitabXref ref;
}
{
  //db:id(qualifier)
  db = safeString() ":" id = safeString() [ "(" text = safeString() ")" ]
  { if (text == null){ref = new MitabXref(db, id, qualifier);}
    else {ref = new MitabXref(db, id, text); getParserListener().onTextFoundInIdentifier(token.beginLine, token.beginColumn, columnNumber);}
    ref.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
    return ref;}
}

java.lang.String safeString():
{java.lang.String text;}
{
  <QUOTED_STRING> {text = token.image.substring(1, token.image.length()).replaceAll("\\\"", "\"").trim();} | <UNRESERVED_STRING> {text = token.image.trim();}
  {return text;}
}
