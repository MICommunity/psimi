
options {
  LOOKAHEAD = 1;
  FORCE_LA_CHECK = true;
  JAVA_UNICODE_ESCAPE = true;
  STATIC = false;
  CHOICE_AMBIGUITY_CHECK = 5;
  OTHER_AMBIGUITY_CHECK = 5;
  IGNORE_CASE = true;
}

PARSER_BEGIN(MitabLineParser)
package psidev.psi.mi.jami.tab.io.parser;

import psidev.psi.mi.jami.model.*;
import psidev.psi.mi.jami.datasource.DefaultFileSourceContext;
import psidev.psi.mi.jami.tab.extension.*;
import psidev.psi.mi.jami.tab.listener.MitabParserListener;
import java.util.Collection;
import java.util.Collections;
import psidev.psi.mi.jami.utils.CvTermUtils;
import psidev.psi.mi.jami.utils.PositionUtils;
import java.util.ArrayList;
import java.util.EnumSet;
import java.lang.NumberFormatException;
import psidev.psi.mi.jami.exception.IllegalParameterException;
import psidev.psi.mi.jami.exception.IllegalRangeException;
import psidev.psi.mi.jami.tab.utils.MitabUtils;

public abstract class MitabLineParser<T extends Interaction, P extends Participant, F extends Feature> {
	
	void processSyntaxError(int lineNumber, int columnNumber, int mitabColumn, Exception e) {
	    fireOnInvalidSyntax(lineNumber, columnNumber, mitabColumn, e);
	}

	void createParseException(int lineNumber, int columnNumber, int mitabColumn, ParseException e, String message) {
	    ParseException e2 = new ParseException(message);
	    e2.currentToken = e.currentToken;
	    e2.expectedTokenSequences = e.expectedTokenSequences;
	    e2.tokenImage = e.tokenImage;
    	processSyntaxError(lineNumber, columnNumber, mitabColumn, e2);
    }

	public abstract MitabParserListener getParserListener();

	public abstract void setParserListener(MitabParserListener listener);

    abstract void fireOnInvalidSyntax(int lineNumber, int columnNumber, int mitabColumn, Exception e);

    abstract void reachEndOfFile();

    public abstract boolean hasFinished();

    abstract java.lang.StringBuilder resetStringBuilder();

    abstract F createFeature(String type, Collection<Range> ranges, String text, int line, int column, int mitabColumn);

	abstract P finishParticipant(Collection<MitabXref> uniqueId, Collection<MitabXref> altid , Collection<MitabAlias> aliases,
	                                       Collection<MitabOrganism> taxid, Collection<MitabCvTerm> bioRole, Collection<MitabCvTerm> expRole,
	                                       Collection<MitabCvTerm> type, Collection<MitabXref> xref, Collection<MitabAnnotation> annot,
	                                       Collection<MitabChecksum> checksum, Collection<F> feature, Collection<MitabStoichiometry> stc,
	                                       Collection<MitabCvTerm> detMethod, int line, int column, int mitabColumn);
	abstract T finishInteraction(P A, P B, Collection<MitabCvTerm> detMethod, Collection<MitabAuthor> firstAuthor,
	                                       Collection<MitabXref> pubId, Collection<MitabCvTerm> interactionType, Collection<MitabSource> source,
	                                       Collection<MitabXref> interactionId, Collection<MitabConfidence> conf, Collection<MitabCvTerm> expansion,
	                                       Collection<MitabXref> xrefI, Collection<MitabAnnotation> annotI, Collection<MitabOrganism> host,
	                                       Collection<MitabParameter> params, Collection<MitabDate> created, Collection<MitabDate> update,
	                                       Collection<MitabChecksum> checksumI, boolean isNegative, int line);
}

PARSER_END(MitabLineParser)

/* WHITE SPACE */

SKIP :
{
  "\r" | "\f"
}

TOKEN :
{
  < RANGE_SEPARATOR: ",">
    | < COMMENT: "#">
    | < FIELD_SEPARATOR: "|">
    | < COLUMN_SEPARATOR: "\t">
    | < LINE_SEPARATOR: "\n">
    | < OPEN_PAREN: "(">
    | < CLOSE_PAREN: ")">
    | < COLON: ":">
    | < DASH: "-" >
}
TOKEN :
{
  < QUOTED_STRING:
    "\"" 
      ( ~["\""] | ("\\" "\"") )* 
    "\""
    >
 |
 < UNRESERVED_STRING:
     (~["\"", "|", "(", ")", ":", "\t", "\n", "-", "#", ","])+
     >
}

T MitabLine():
{
  Collection<MitabXref> uniqueIdA = Collections.EMPTY_LIST;
  Collection<MitabXref> uniqueIdB = Collections.EMPTY_LIST;
  Collection<MitabXref> altIdA = Collections.EMPTY_LIST;
  Collection<MitabXref> altIdB = Collections.EMPTY_LIST;
  Collection<MitabAlias> aliasA = Collections.EMPTY_LIST;
  Collection<MitabAlias> aliasB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> detMethod = Collections.EMPTY_LIST;
  Collection<MitabAuthor> firstAuthor = Collections.EMPTY_LIST;
  Collection<MitabXref> pubId = Collections.EMPTY_LIST;
  Collection<MitabOrganism> taxidA = Collections.EMPTY_LIST;
  Collection<MitabOrganism> taxidB= Collections.EMPTY_LIST;
  Collection<MitabCvTerm> interactionType = Collections.EMPTY_LIST;
  Collection<MitabSource> source = Collections.EMPTY_LIST;
  Collection<MitabXref> interactionId = Collections.EMPTY_LIST;
  Collection<MitabConfidence> conf = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> expansion = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> bioRoleA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> bioRoleB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> expRoleA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> expRoleB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> typeA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> typeB = Collections.EMPTY_LIST;
  Collection<MitabXref> xrefA = Collections.EMPTY_LIST;
  Collection<MitabXref> xrefB = Collections.EMPTY_LIST;
  Collection<MitabXref> xrefI = Collections.EMPTY_LIST;
  Collection<MitabAnnotation> annotA = Collections.EMPTY_LIST;
  Collection<MitabAnnotation> annotB = Collections.EMPTY_LIST;
  Collection<MitabAnnotation> annotI = Collections.EMPTY_LIST;
  Collection<MitabOrganism> host = Collections.EMPTY_LIST;
  Collection<MitabParameter> params = Collections.EMPTY_LIST;
  Collection<MitabDate> created = Collections.EMPTY_LIST;
  Collection<MitabDate> update = Collections.EMPTY_LIST;
  Collection<MitabChecksum> checksumA = Collections.EMPTY_LIST;
  Collection<MitabChecksum> checksumB = Collections.EMPTY_LIST;
  Collection<MitabChecksum> checksumI = Collections.EMPTY_LIST;
  boolean isNegative = false;
  Collection<F> featureA = Collections.EMPTY_LIST;
  Collection<F> featureB = Collections.EMPTY_LIST;
  Collection<MitabStoichiometry> stcA = Collections.EMPTY_LIST;
  Collection<MitabStoichiometry> stcB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> pmethodA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> pmethodB = Collections.EMPTY_LIST;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR);
  EnumSet<TokenKind> columnSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);

  P participantA=null;
  P participantB=null;
  T interaction=null;
  int line;
  int columnA;
  int columnB;
  CvTerm identity = CvTermUtils.createIdentityQualifier();
}
{
     //allow empty lines
    try{

   ((<LINE_SEPARATOR>)
    |
   (<EOF> {reachEndOfFile();})
    |
   ( <COMMENT> anyStringBut(enumSet) (<LINE_SEPARATOR> | <EOF> {reachEndOfFile();}))
    |
      (
        try{(<DASH> {uniqueIdA = Collections.EMPTY_LIST; line = token.beginLine; columnA = token.beginColumn;} | uniqueIdA = ids(identity, false, 1)) {line = token.beginLine; columnA = token.beginColumn;} <COLUMN_SEPARATOR>}
        catch (ParseException e){
          line = token.beginLine;
          columnA = token.beginColumn;
          createParseException(line, columnA, 1, e, "Invalid syntax in unique identifier A column. Expect database xrefs of type db:id separated by '|'.");
          error_skipToNext(columnSet, true);
         }
        try{(<DASH> {uniqueIdB = Collections.EMPTY_LIST; columnB = token.beginColumn;} | uniqueIdB = ids(identity, false, 2)) {columnB = token.beginColumn;} <COLUMN_SEPARATOR>}
        catch (ParseException e){
            line = token.beginLine;
            columnB = token.beginColumn;
            createParseException(line, columnB, 2, e, "Invalid syntax in unique identifier B column. Expect database xrefs of type db:id separated by '|'.");
             error_skipToNext(columnSet, true);
        }
        try{(<DASH> {altIdA = Collections.EMPTY_LIST;} | altIdA = ids(CvTermUtils.getSecondary(), false, 3)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 3, e, "Invalid syntax in alternative identifiers A column. Expect database xrefs of type db:id separated by '|'.");
                  error_skipToNext(columnSet, true);
        }
        try{(<DASH> {altIdB = Collections.EMPTY_LIST;} | altIdB = ids(CvTermUtils.getSecondary(), false, 4)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 4, e, "Invalid syntax in alternative identifiers B column. Expect database xrefs of type db:id separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {aliasA = Collections.EMPTY_LIST;} | aliasA = aliases(5)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 5, e, "Invalid syntax in aliases A column. Expected aliases of type db:name(alias type) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {aliasB = Collections.EMPTY_LIST;} | aliasB = aliases(6)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 6, e, "Invalid syntax in aliases B column. Expected aliases of type db:name(alias type) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {detMethod = Collections.EMPTY_LIST;} | detMethod = cvTerms(7)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 7, e, "Invalid syntax in interaction detection method column. Expected xrefs of type psi-mi:\"MI id\"(name) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(LOOKAHEAD(2) <DASH> {firstAuthor = Collections.EMPTY_LIST;} <COLUMN_SEPARATOR> | firstAuthor = firstAuthors() <COLUMN_SEPARATOR>)}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 8, e, "Invalid syntax in first author column. Expected authors of type author_name et al.(publication year) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {pubId = Collections.EMPTY_LIST;} | pubId = ids(identity, true, 9)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 9, e, "Invalid syntax in publication identifiers column. Expected xrefs of type db:id separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {taxidA = Collections.EMPTY_LIST;} | taxidA = taxId(10)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 10, e, "Invalid syntax in taxid A column. Expected organism of type taxid:id(organism name) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {taxidB = Collections.EMPTY_LIST;} | taxidB = taxId(11)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 11, e, "Invalid syntax in taxid B column. Expected organism of type taxid:id(organism name) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {interactionType = Collections.EMPTY_LIST;} | interactionType = cvTerms(12)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 12, e, "Invalid syntax in interaction type column. Expected xrefs of type psi-mi:\"MI id\"(name) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {source = Collections.EMPTY_LIST;} | source = sourceDbs()) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 13, e, "Invalid syntax in source column. Expected xrefs of type psi-mi:\"MI id\"(name) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {interactionId = Collections.EMPTY_LIST;} | interactionId = ids(identity, true, 14)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 14, e, "Invalid syntax in interaction identifiers column. Expected xrefs of type db:id(qualifier) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {conf = Collections.EMPTY_LIST;} | conf = confidences())}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 15, e, "Invalid syntax in confidences column. Expected confidences of type confidence_type:value separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }

        [ //starting MITAB 2.6
        (
        <COLUMN_SEPARATOR> //end of confidences delimiter
        try{(<DASH> {expansion = Collections.EMPTY_LIST;} | expansion = complexExpansion()) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 16, e, "Invalid syntax in complex expansion column. Expected xrefs of type psi-mi:\"MI id\"(name).");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {bioRoleA = Collections.EMPTY_LIST;} | bioRoleA = cvTerms(17)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 17, e, "Invalid syntax in biological role A column. Expected xrefs of type psi-mi:\"MI id\"(name) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {bioRoleB = Collections.EMPTY_LIST;} | bioRoleB = cvTerms(18)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 18, e, "Invalid syntax in biological role B column. Expected xrefs of type psi-mi:\"MI id\"(name) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {expRoleA = Collections.EMPTY_LIST;} | expRoleA = cvTerms(19)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 19, e, "Invalid syntax in experimental role A column. Expected xrefs of type psi-mi:\"MI id\"(name) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {expRoleB = Collections.EMPTY_LIST;} | expRoleB = cvTerms(20)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 20, e, "Invalid syntax in experimental role B column. Expected xrefs of type psi-mi:\"MI id\"(name) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {typeA = Collections.EMPTY_LIST;} | typeA = cvTerms(21)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 21, e, "Invalid syntax in interactor type A column. Expected xrefs of type psi-mi:\"MI id\"(name) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {typeB = Collections.EMPTY_LIST;} | typeB = cvTerms(22)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 22, e, "Invalid syntax in interactor type B column. Expected xrefs of type psi-mi:\"MI id\"(name) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {xrefA = Collections.EMPTY_LIST;} | xrefA = ids(null, false, 23)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 23, e, "Invalid syntax in interactor xrefs A column. Expected xrefs of type db:id(qualifier) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {xrefB = Collections.EMPTY_LIST;} | xrefB = ids(null, false, 24)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 24, e, "Invalid syntax in interactor xrefs B column. Expected xrefs of type db:id(qualifier) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {xrefI = Collections.EMPTY_LIST;} | xrefI = ids(null, false, 25)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 25, e, "Invalid syntax in interaction xrefs column. Expected xrefs of type db:id(qualifier) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {annotA = Collections.EMPTY_LIST;} | annotA = annotations(26)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 26, e, "Invalid syntax in interactor annotations A column. Expected annotations of type topic:value or topic separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {annotB = Collections.EMPTY_LIST;} | annotB = annotations(27)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 27, e, "Invalid syntax in interactor annotations B column. Expected annotations of type topic:value or topic separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {annotI = Collections.EMPTY_LIST;} | annotI = annotations(28)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 28, e, "Invalid syntax in interaction annotations column. Expected annotations of type topic:value or topic separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {host = Collections.EMPTY_LIST;} | host = taxId(29)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 29, e, "Invalid syntax in host organism column. Expected organism of type taxid:id(organism name) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {params = Collections.EMPTY_LIST;} | params = parameters()) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 30, e, "Invalid syntax in interaction parameters column. Expected parameter of type parameter_type:value(unit) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {created = Collections.EMPTY_LIST;} | created = dates(31)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 31, e, "Invalid syntax in created date column. Expected dates of type yyyy/MM/dd separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {update = Collections.EMPTY_LIST;} | update = dates(32)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 32, e, "Invalid syntax in update date column. Expected dates of type yyyy/MM/dd separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {checksumA = Collections.EMPTY_LIST;} | checksumA = checksums(33)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 33, e, "Invalid interactor checksum A column. Expected checksums of type checksum_name:value separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {checksumB = Collections.EMPTY_LIST;} | checksumB = checksums(34)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 34, e, "Invalid interactor checksum B column. Expected checksums of type checksum_name:value separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {checksumI = Collections.EMPTY_LIST;} | checksumI = checksums(35)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 35, e, "Invalid interaction checksum column. Expected checksums of type checksum_name:value separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> | isNegative = negative())}
        catch (ParseException e){
             createParseException(token.beginLine, token.beginColumn, 36, e, "Invalid negative column. Expected boolean value 'true' or 'false'.");
             error_skipToNext(columnSet, true);
         }
        [ //starting MITAB 2.7
        (
        <COLUMN_SEPARATOR> //end of negative() delimiter
        try{(<DASH> {featureA = Collections.EMPTY_LIST;} | featureA = features(37)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 37, e, "Invalid features A column. Expected features of type feature_type:range1,range2(text) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {featureB = Collections.EMPTY_LIST;} | featureB = features(38)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 38, e, "Invalid features B column. Expected features of type feature_type:range1,range2(text) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(LOOKAHEAD(2) <DASH> {stcA = Collections.EMPTY_LIST;} <COLUMN_SEPARATOR> | stcA = stoichiometryList(39) <COLUMN_SEPARATOR>)}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 39, e, "Invalid stoichiometry A column. Expected stoichiometry values of type integer.");
                  error_skipToNext(columnSet, true);
                 }
        try{(LOOKAHEAD(2) <DASH> {stcB = Collections.EMPTY_LIST;} <COLUMN_SEPARATOR> | stcB = stoichiometryList(40) <COLUMN_SEPARATOR>)}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 40, e, "Invalid stoichiometry B column. Expected stoichiometry values of type integer.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {pmethodA = Collections.EMPTY_LIST;} | pmethodA = cvTerms(41)) <COLUMN_SEPARATOR>}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 41, e, "Invalid participant identification methods A column. Expected xrefs of type psi-mi:\"MI id\"(name) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        try{(<DASH> {pmethodB = Collections.EMPTY_LIST;} | pmethodB = cvTerms(42))}
        catch (ParseException e){
                  createParseException(token.beginLine, token.beginColumn, 42, e, "Invalid participant identification methods B column. Expected xrefs of type psi-mi:\"MI id\"(name) separated by '|'.");
                  error_skipToNext(columnSet, true);
                 }
        )
        ] // end MITAB 2.7
         )
        ] //end MITAB 2.6
              {
                participantA = finishParticipant(uniqueIdA, altIdA, aliasA, taxidA, bioRoleA, expRoleA, typeA, xrefA, annotA, checksumA, featureA, stcA, pmethodA, line, columnA, 1);
                participantB = finishParticipant(uniqueIdB, altIdB, aliasB, taxidB, bioRoleB, expRoleB, typeB, xrefB, annotB, checksumB, featureB, stcB, pmethodB, line, columnB, 2);
                interaction = finishInteraction(participantA, participantB, detMethod, firstAuthor, pubId, interactionType, source, interactionId,
                                         conf, expansion, xrefI, annotI, host, params, created, update, checksumI, isNegative, line);
              }
      (try{<LINE_SEPARATOR> | <EOF> {reachEndOfFile();}}
       catch (ParseException e){
           createParseException(token.beginLine, token.beginColumn, 0, e, "Invalid number of columns. Expected 15, 36 or 42 tab separated columns.");
           error_skipToNext(enumSet, true);
      }))
      )
      {return interaction;}
      }
       catch (ParseException e){
        createParseException(token.beginLine, token.beginColumn, 0, e, "Invalid MITAB line syntax. Expected 15, 36 or 42 tab separated columns per line and all special characters should be escaped by double quote. See MITAB format description");
        error_skipToNext(enumSet, true);
        return interaction;
      }
}

Collection<MitabXref> ids(CvTerm qualifier, boolean recognizeImex, int column):
{
  Collection<MitabXref> xrefs;
  MitabXref var;
}
{
   var = id(qualifier, recognizeImex, column)
   {xrefs = new ArrayList<MitabXref>(); if (var != null) {xrefs.add(var);}}

   (<FIELD_SEPARATOR> var = id(qualifier, recognizeImex, column) {if (var != null) {xrefs.add(var);}})*
   {return xrefs;}
}

Collection<MitabAlias> aliases(int column):
{
  Collection<MitabAlias> aliases;
  MitabAlias var;
}
{
    var = alias(column)
    {aliases = new ArrayList<MitabAlias>(); if (var != null) {if (var != null) {aliases.add(var);}}}

    (<FIELD_SEPARATOR> var = alias(column) {if (var != null) {if (var != null) {aliases.add(var);}}})*
    {return aliases;}
}

Collection<MitabCvTerm> cvTerms(int columnNumber):
{
  Collection<MitabCvTerm> methods;
  MitabCvTerm var;
}
{
  var = cvTerm(columnNumber)
    {methods = new ArrayList<MitabCvTerm>(); if (var != null) {methods.add(var);}}

    (<FIELD_SEPARATOR> var = cvTerm(columnNumber) {if (var != null) {methods.add(var);}})*
    {return methods;}
}

Collection<MitabAuthor> firstAuthors():
{
  Collection<MitabAuthor> authors;
  MitabAuthor var;
}
{
    var = author()
    {authors = new ArrayList<MitabAuthor>(); if (var != null) {authors.add(var);}}

    (<FIELD_SEPARATOR> var = author() {if (var != null) {authors.add(var);}})*
    {return authors;}
}

Collection<MitabOrganism> taxId(int column):
{
  Collection<MitabOrganism> organisms;
  MitabOrganism var;
  }
{
    var = organism(column)
    {organisms = new ArrayList<MitabOrganism>(); if (var != null) {organisms.add(var);}}

    (<FIELD_SEPARATOR> var = organism(column) {if (var != null) {organisms.add(var);}})*
    {return organisms;}
}

Collection<MitabSource> sourceDbs():
{
  Collection<MitabSource> sources;
  MitabSource var;
}
{
     var = source()
    {sources = new ArrayList<MitabSource>(); if (var != null) {sources.add(var);}}

    (<FIELD_SEPARATOR> var = source() {if (var != null) {sources.add(var);}})*
    {return sources;}
}

Collection<MitabConfidence> confidences():
{
  Collection<MitabConfidence> confs;
  MitabConfidence var;
}
{
    var = confidence()
    {confs = new ArrayList<MitabConfidence>(); if (var != null) {confs.add(var);}}

    (<FIELD_SEPARATOR> var = confidence() {if (var != null) {confs.add(var);}})*
    {return confs;}
}

Collection<MitabCvTerm> complexExpansion():
{
  Collection<MitabCvTerm> expansions;
  MitabCvTerm var;
}
{
    var = expansion()
    {expansions = new ArrayList<MitabCvTerm>(); if (var != null) {expansions.add(var);}}

    (<FIELD_SEPARATOR> var = expansion() {if (var != null) {expansions.add(var);}})*
    {return expansions;}
}

Collection<MitabAnnotation> annotations(int column):
{
  Collection<MitabAnnotation> annots;
  MitabAnnotation var;
}
{
    var = annotation(column)
      {annots = new ArrayList<MitabAnnotation>(); if (var != null) {annots.add(var);}}

      (<FIELD_SEPARATOR> var = annotation(column) {if (var != null) {annots.add(var);}})*
      {return annots;}
}

Collection<MitabParameter> parameters():
{
  Collection<MitabParameter> params;
  MitabParameter var;
}
{
    var = parameter()
    {params = new ArrayList<MitabParameter>(); if (var != null) {params.add(var);}}

    (<FIELD_SEPARATOR> var = parameter() {if (var != null) {params.add(var);}})*
    {return params;}
}

Collection<MitabDate> dates(int column):
{
  Collection<MitabDate> dates;
  MitabDate var;
}
{
    var = date(column)
      {dates = new ArrayList<MitabDate>(); if (var != null) {if (var != null) {dates.add(var);}}}

      (<FIELD_SEPARATOR> var = date(column) {if (var != null) {if (var != null) {if (var != null) {dates.add(var);}}}})*
      {return dates;}
}

Collection<MitabChecksum> checksums(int column):
{
  Collection<MitabChecksum> checksums;
  MitabChecksum var;
}
{
      var = checksum(column)
      {checksums = new ArrayList<MitabChecksum>(); if (var != null) {checksums.add(var);}}

      (<FIELD_SEPARATOR> var = checksum(column) {if (var != null) {checksums.add(var);}})*
      {return checksums;}
}

Collection<F> features(int column):
{
  Collection<F> features;
  F var;
}
{
       var = feature(column)
       {features = new ArrayList<F>(); if (var != null) {features.add(var);}}

       (<FIELD_SEPARATOR> var = feature(column) {if (var != null) {features.add(var);}})*
       {return features;}
}

Collection<MitabStoichiometry> stoichiometryList(int column):
{
  Collection<MitabStoichiometry> stc;
  MitabStoichiometry var;
}
{
    var = stoichiometry(column)
    {stc = new ArrayList<MitabStoichiometry>(); if (var != null) {stc.add(var);}}

    (<FIELD_SEPARATOR> var = stoichiometry(column) {if (var != null) {stc.add(var);}})*
    {return stc;}
}

MitabStoichiometry stoichiometry(int columnNumber):
{
  int min;
  int max = 0;
  java.lang.String minString;
  java.lang.String maxString = null;
  int beginLine=0;
  int beginColumn=0;
  MitabStoichiometry stc;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //float
    minString = safeStoichiometry()
    {
        beginLine = token.beginLine;
        beginColumn = token.beginColumn;
      }
      [ "-" maxString = safeStoichiometry()
      ]
      {
         try{
         min = Integer.parseInt(minString);
         }
         catch(NumberFormatException e){
             min=0;
             if (getParserListener() != null){getParserListener().onInvalidStoichiometry(e.getMessage(), new DefaultFileSourceContext(new MitabSourceLocator(beginLine, beginColumn, columnNumber)));}
         }
         if (maxString != null){
            try{
            max = Integer.parseInt(maxString);
            }
            catch(NumberFormatException e){
                max=min;
                if (getParserListener() != null){getParserListener().onInvalidStoichiometry(e.getMessage(), new DefaultFileSourceContext(new MitabSourceLocator(beginLine, beginColumn, columnNumber)));}
            }
            try{
            stc = new MitabStoichiometry(min, max);
            }catch(IllegalArgumentException e){
                stc = new MitabStoichiometry(0);
                if (getParserListener() != null){getParserListener().onInvalidStoichiometry(e.getMessage(), stc);}
            }
         }
         else{
            stc = new MitabStoichiometry(min);
         }
         stc.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
         return stc;
      }
  }
  catch (ParseException e){
       createParseException(token.beginLine, token.beginColumn, columnNumber, e, "Invalid stoichiometry value. Expected integer values.");
        error_skipToNext(enumSet, true);
        return null;
   }
}

F feature(int columnNumber):
{
  java.lang.String type;
  Collection<Range> ranges;
  Range var;
  java.lang.String text = null;
  F feature;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //type:range1,range2(text)
    type = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> var = range(columnNumber)
    {ranges = new ArrayList<Range>(); if (var != null) {ranges.add(var);}}
    (<RANGE_SEPARATOR> var = range(columnNumber) {if (var != null) {ranges.add(var);}})* [ <OPEN_PAREN> text = safeString() <CLOSE_PAREN> ]
    {
        feature = createFeature(type, ranges, text, beginLine, beginColumn, columnNumber);

        return feature;
      }
  }
  catch (ParseException e){
     createParseException(token.beginLine, token.beginColumn, columnNumber, e, "Invalid feature. Expected features of type feature_type:range1,range2(text)");
      error_skipToNext(enumSet, true);
      return null;
  }
 catch(IllegalArgumentException e){
         processSyntaxError(beginLine, beginColumn, columnNumber, e);
         return null;
      }
}

MitabRange range(int columnNumber):
{
  Position start;
  Position end;
  java.lang.String startString;
  java.lang.String endString;
  MitabRange range;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.RANGE_SEPARATOR, TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{

    //x-x
    (startString = safePosition()
    { beginLine = token.beginLine; beginColumn = token.beginColumn;
    }
    "-" endString = safePosition())
     {  try{
        start = PositionUtils.createPositionFromString(startString);
        }catch(IllegalRangeException e){
            start = PositionUtils.createUndeterminedPosition();
            if (getParserListener() != null){getParserListener().onInvalidPosition(e.getMessage(), new DefaultFileSourceContext(new MitabSourceLocator(beginLine, beginColumn, columnNumber)));}
        }
        catch(IllegalArgumentException e){
            start = PositionUtils.createUndeterminedPosition();
            if (getParserListener() != null){getParserListener().onInvalidPosition(e.getMessage(), new DefaultFileSourceContext(new MitabSourceLocator(beginLine, beginColumn, columnNumber)));}
        }
        try{
        end = PositionUtils.createPositionFromString(endString);
        }catch(IllegalRangeException e){
            end = PositionUtils.createUndeterminedPosition();
            if (getParserListener() != null){getParserListener().onInvalidPosition(e.getMessage(), new DefaultFileSourceContext(new MitabSourceLocator(beginLine, beginColumn, columnNumber)));}
        }
        catch(IllegalArgumentException e){
            end = PositionUtils.createUndeterminedPosition();
            if (getParserListener() != null){getParserListener().onInvalidPosition(e.getMessage(), new DefaultFileSourceContext(new MitabSourceLocator(beginLine, beginColumn, columnNumber)));}
        }
        try{
        range = new MitabRange(start, end);
        range.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        }
        catch(IllegalArgumentException e){
            range = new MitabRange(PositionUtils.createUndeterminedPosition(), PositionUtils.createUndeterminedPosition());
            range.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
            if (getParserListener() != null){getParserListener().onInvalidRange(e.getMessage(), range);}
        }
       return range;}
  }
  catch (ParseException e){
      createParseException(token.beginLine, token.beginColumn, columnNumber, e, "Invalid range. Expected range values pos1-pos2,  pos1..pos2-pos3..pos4, ?-?, n-n or c-c");
      error_skipToNext(enumSet, true);
      return null;
    }
}

boolean negative():
{
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
  java.lang.String value;
}
{
  try{
  //false or true
    value = safeFreeText() { return Boolean.parseBoolean(value);}
  }
  catch (ParseException e){
    createParseException(token.beginLine, token.beginColumn, 16, e, "Invalid negative boolean value. Expected 'true' or 'false'");
     error_skipToNext(enumSet, true);
     return false;
  }
}

MitabChecksum checksum(int columnNumber):
{
  java.lang.String method;
  java.lang.String value;
  MitabChecksum checksum;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //method:value
    method = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> value = safeString()
    {
        checksum = new MitabChecksum(method, value);
        checksum.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        if (method == null && getParserListener() != null){getParserListener().onMissingChecksumMethod(checksum);}
        if (value == null && getParserListener() != null){getParserListener().onMissingChecksumValue(checksum);}
        return checksum;
      }
  }
  catch (ParseException e){
       createParseException(token.beginLine, token.beginColumn, columnNumber, e, "Invalid checksum. Expected checksum_name:value");
       error_skipToNext(enumSet, true);
        return null;
    }
}

MitabDate date(int columnNumber):
{
  java.lang.String date;
  MitabDate mitabDate;
  int beginLine = 0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //yyyy/mm/dd
    date = safeString()
    { beginLine = token.beginLine; beginColumn = token.beginColumn; mitabDate = new MitabDate(date);
        mitabDate.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
        return mitabDate;
     }
  }
  catch (ParseException e){
     createParseException(token.beginLine, token.beginColumn, columnNumber, e, "Invalid date. Expected yyyy/MM/dd");
     error_skipToNext(enumSet, true);
      return null;
  }
  catch (java.text.ParseException e){
     processSyntaxError(beginLine, beginColumn, columnNumber, e);
     return null;
  }
}

MitabParameter parameter() :
{
  java.lang.String type;
  java.lang.String value;
  java.lang.String unit = null;
  MitabParameter param;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //type:value(unit)
    type = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> value = safeString() [ <OPEN_PAREN> unit = safeString() <CLOSE_PAREN> ]
    {param = new MitabParameter(type, value, unit);
     param.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 30));
     if (type == null && getParserListener() != null){getParserListener().onMissingParameterType(param);}
     if (value == null && getParserListener() != null){getParserListener().onMissingParameterValue(param);}
     return param;
     }
  }
  catch (ParseException e){
      createParseException(token.beginLine, token.beginColumn, 30, e, "Invalid parameter. Expected parameter_type:value(unit)");
       error_skipToNext(enumSet, true);
       return null;
   }
   catch (IllegalParameterException e){
         processSyntaxError(beginLine, beginColumn, 30, e);
         return null;
    }
}

MitabAnnotation annotation(int columnNumber):
{
  java.lang.String topic;
  java.lang.String value = null;
  MitabAnnotation annot;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //topic:value
    topic = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} [ <COLON> value = safeString() ]
    { annot = new MitabAnnotation(topic, value);
      annot.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
      if (topic == null && getParserListener() != null){getParserListener().onAnnotationWithoutTopic(annot);}
      return annot;}
  }
  catch (ParseException e){
         createParseException(token.beginLine, token.beginColumn, columnNumber, e, "Invalid annotation. Expected topic:value or just topic.");
         error_skipToNext(enumSet, true);
         return null;
      }
}

MitabCvTerm expansion():
{
  java.lang.String db = null;
  java.lang.String id = null;
  java.lang.String name = null;
  MitabCvTerm cv;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
  //db:id(name) or just name for backward compatibility
    db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> id = safeString() [ <OPEN_PAREN> name = safeString() <CLOSE_PAREN> ]
    { if (id == null) {cv = new MitabCvTerm(name);
            cv.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 16));
            if (getParserListener() != null) {getParserListener().onMissingExpansionId(cv);}}
      else {cv = new MitabCvTerm(name, null, db, id); cv.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 16));}
      if (name == null && getParserListener() != null){getParserListener().onMissingCvTermName(cv, cv,  "The expansion method at the column 16 does not have a name.");}
      return cv;}
  }
  catch (ParseException e){
     createParseException(token.beginLine, token.beginColumn, 16, e, "Invalid complex expansion method. Expected PSI-MI controlled vocabulary xref");
     error_skipToNext(enumSet, true);
     return null;
  }
}

MitabConfidence confidence():
{
 java.lang.String type;
 java.lang.String value;
 java.lang.String text = null;
  MitabConfidence conf;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    type = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> value = safeString() [ <OPEN_PAREN> text = safeString() <CLOSE_PAREN> ]
    { if (text == null){conf = new MitabConfidence(type, value, null); conf.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 15));}
      else {conf = new MitabConfidence(type, value, text); conf.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 15));
             if (getParserListener() != null) {getParserListener().onTextFoundInConfidence(conf);}}
      if (type == null && getParserListener() != null){getParserListener().onMissingConfidenceType(conf);}
      if (value == null && getParserListener() != null){getParserListener().onMissingConfidenceValue(conf);}
      return conf;}
  }
  catch (ParseException e){
     createParseException(token.beginLine, token.beginColumn, 15, e, "Invalid confidence. Expected confidence_type:value");
     error_skipToNext(enumSet, true);
     return null;
  }
}

MitabSource source():
{
  java.lang.String db;
  java.lang.String id;
  java.lang.String name = null;
  MitabSource s;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try {
     //db:id(name)
       db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> id = safeString() [ <OPEN_PAREN> name = safeString() <CLOSE_PAREN> ]
       { s = new MitabSource(name, null, db, id); s.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 13));
         if (name == null && getParserListener() != null){getParserListener().onMissingCvTermName(s, s,  "The source at the column 13 does not have a name.");}
         return s;}
  }
  catch (ParseException e){
        createParseException(token.beginLine, token.beginColumn, 13, e, "Invalid source. Expected PSI-MI controlled vocabulary xref");
        error_skipToNext(enumSet, true);
        return null;
  }
}

MitabOrganism organism(int columnNumber):
{
  java.lang.String id;
  java.lang.String name = null;
  java.lang.String db;
  MitabOrganism organism;
  int beginLine=0;
  int beginColumn=0;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try {
  //taxid:id(name)
    (db = safeString()
    {if (!db.equalsIgnoreCase("taxid"))
    { processSyntaxError(token.beginLine, token.beginColumn, columnNumber, new java.lang.RuntimeException("Found " + db + " instead of expected taxid."));
      error_skipToNext(enumSet, false); return null;
      }
    }
     <COLON> id = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} [ <OPEN_PAREN> name = safeString() <CLOSE_PAREN> ] )
    {
    try{
       int tax = Integer.parseInt(id);
       organism = new MitabOrganism(tax, name);
       organism.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       if ((tax == 0 || tax < -5) && getParserListener() != null){getParserListener().onInvalidOrganismTaxid(id, organism);}
       return organism;
       }catch (NumberFormatException e){
             organism = new MitabOrganism(-3, name);
             organism.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
             if (getParserListener() != null){getParserListener().onInvalidOrganismTaxid(id, organism);}
             return organism;
       }
     }
  }
  catch (ParseException e){
           createParseException(token.beginLine, token.beginColumn, columnNumber, e, "Invalid organism. Expected taxid:id(organism name)");
           error_skipToNext(enumSet, true);
           return null;
  }
}

MitabAuthor author():
{
 MitabAuthor auth;
 java.lang.String first=null;
 int beginLine;
 int beginColumn;
 EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
     first = safeFreeText()
     { beginLine = token.beginLine; beginColumn = token.beginColumn;
       auth = new MitabAuthor(first);
       auth.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 8));
       return auth;
      }
  }
  catch (ParseException e){
       createParseException(token.beginLine, token.beginColumn, 8, e, "Invalid first author. Expected author name et al. (publication year)");
       error_skipToNext(enumSet, true);
       return null;
  }
}

MitabCvTerm cvTerm(int column):
{
  java.lang.String db;
  java.lang.String id = null;
  java.lang.String name = null;
  int beginLine=0;
  int beginColumn=0;
  MitabCvTerm cv;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  //db:id(name)
  try{
    db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> id = safeString() [ <OPEN_PAREN> name = safeString() <CLOSE_PAREN> ]
    { cv = new MitabCvTerm(name, null, db, id); cv.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, column));
      if (name == null && getParserListener() != null){getParserListener().onMissingCvTermName(cv, cv,  "The term at the column " + column + " does not have a name.");}
      return cv;}
  }
  catch (ParseException e){
     createParseException(token.beginLine, token.beginColumn, column, e, "Invalid controlled vocabulary term. Expected a xref to PSI-MI ontology");
     error_skipToNext(enumSet, true);
     return null;
  }
}

MitabAlias alias(int columnNumber):
{
  java.lang.String db;
  java.lang.String name;
  java.lang.String type = null;
  int beginLine=0;
  int beginColumn=0;
  MitabAlias alias;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  //db:name(type)
  try{
      db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> name = safeString() [ <OPEN_PAREN> type = safeString() <CLOSE_PAREN> ]
      { alias = new MitabAlias(db, name, type);
        alias.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        if (db == null && getParserListener() != null){getParserListener().onAliasWithoutDbSource(alias);}
        if (name == null && getParserListener() != null){getParserListener().onAliasWithoutName(alias);}
        return alias;}
  }
  catch(ParseException e){
      createParseException(token.beginLine, token.beginColumn, columnNumber, e, "Invalid alias. Expected db:name(alias type)");
      error_skipToNext(enumSet, true);
      return null;
  }
}

MitabXref id(CvTerm qualifier, boolean recognizeImexPrimary, int columnNumber):
{
  java.lang.String db;
  java.lang.String id;
  java.lang.String text = null;
  int beginLine=0;
  int beginColumn=0;
  MitabXref ref;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
  //db:id(qualifier)
    db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> id = safeString() [ <OPEN_PAREN> text = safeString() <CLOSE_PAREN> ]
    { if (recognizeImexPrimary && Xref.IMEX.equalsIgnoreCase(db.trim())){
         if (text == null){ref = new MitabXref(db, id, CvTermUtils.getImexPrimary()); ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));}
         else if (qualifier != null) {ref = new MitabXref(db, id, text);
         ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
         if (getParserListener() != null) {getParserListener().onTextFoundInIdentifier(ref);}}
         else {ref = new MitabXref(db, id, text); ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));}
       }
       else if (text == null) {
         ref = new MitabXref(db, id, qualifier);
         ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       }
       else if (qualifier != null) {
          ref = new MitabXref(db, id, text);
          ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
          if (getParserListener() != null) {getParserListener().onTextFoundInIdentifier(ref);}
       }
       else{
          ref = new MitabXref(db, id, text);
          ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       }
       if (db == null && getParserListener() != null){getParserListener().onXrefWithoutDatabase(ref);}
       if (id == null && getParserListener() != null){getParserListener().onXrefWithoutId(ref);}
       return ref;}
   }
   catch(ParseException e){
      createParseException(token.beginLine, token.beginColumn, columnNumber, e, "Invalid database identifier. Expected db:id");
      error_skipToNext(enumSet, true);
      return null;
   }
}

java.lang.String safeString():
{
  java.lang.String result = null;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.COLON, TokenKind.OPEN_PAREN, TokenKind.CLOSE_PAREN, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  ( <QUOTED_STRING> {result = MitabUtils.unescapeDoubleQuote(token.image.substring(1,token.image.length() - 1).trim());}
   | result = anyStringBut(enumSet) )
  {return result;}
}

java.lang.String safeFreeText():
{
  java.lang.String result = null;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  ( <QUOTED_STRING> {result = MitabUtils.unescapeDoubleQuote(token.image.substring(1,token.image.length() - 1).trim());}
   | result = anyStringBut(enumSet)    )
  {return result;}
}

java.lang.String safePosition():
{
  java.lang.String result = null;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.DASH, TokenKind.RANGE_SEPARATOR, TokenKind.FIELD_SEPARATOR, TokenKind.OPEN_PAREN, TokenKind.CLOSE_PAREN, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  ( <QUOTED_STRING> {result = MitabUtils.unescapeDoubleQuote(token.image.substring(1,token.image.length() - 1).trim());}
   | result = anyStringBut(enumSet)    )
  {return result;}
}

java.lang.String safeStoichiometry():
{
  java.lang.String result = null;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.DASH, TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  ( <QUOTED_STRING> {result = MitabUtils.unescapeDoubleQuote(token.image.substring(1,token.image.length() - 1).trim());}
   | result = anyStringBut(enumSet)    )
  {return result;}
}

JAVACODE
java.lang.String anyStringBut(EnumSet<TokenKind> skipToTokens) {
  java.lang.StringBuilder result = resetStringBuilder();

  Token t = getToken(1);
  // next token is 1
  while(t.kind != EOF && !skipToTokens.contains(TokenKind.getFromTokenKind(t.kind))){
      t = getNextToken();
      // check next token
      result.append(t.image);
      t = getToken(1);
  }
  java.lang.String resultStr = result.toString().trim();
  return resultStr.length() > 0 ? resultStr : null;
}

JAVACODE
void error_skipToNext(EnumSet<TokenKind> skipToTokens, boolean writeError) {
   if (writeError){
    ParseException e = generateParseException();  // generate the exception object.
    System.out.println(e.toString());  // print the error message
   }

  Token t = getToken(0);
  while(t.kind != EOF && !skipToTokens.contains(TokenKind.getFromTokenKind(t.kind))){
     // check next token
     t = getNextToken();
  }
    // The above loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
    // "if"/"while".
}
