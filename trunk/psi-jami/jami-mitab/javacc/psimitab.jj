
options {
  LOOKAHEAD = 1;
  FORCE_LA_CHECK = true;
  JAVA_UNICODE_ESCAPE = true;
  STATIC = false;
}

PARSER_BEGIN(MitabLineParser)
package psidev.psi.mi.jami.tab.io.parser;

import psidev.psi.mi.jami.model.*;
import psidev.psi.mi.jami.tab.extension.*;
import java.util.Collection;
import java.util.Collections;
import psidev.psi.mi.jami.utils.CvTermUtils;
import psidev.psi.mi.jami.utils.PositionUtils;
import psidev.psi.mi.jami.utils.XrefUtils;
import psidev.psi.mi.jami.utils.RangeUtils;
import psidev.psi.mi.jami.tab.listener.MitabParserListener;
import java.util.ArrayList;
import java.util.EnumSet;
import java.lang.NumberFormatException;
import java.util.Date;
import psidev.psi.mi.jami.exception.IllegalParameterException;
import psidev.psi.mi.jami.exception.IllegalRangeException;
import psidev.psi.mi.jami.tab.utils.MitabWriterUtils;

public abstract class MitabLineParser extends AbstractMitabDataSource{
	
	void processSyntaxError(int lineNumber, int columnNumber, int mitabColumn, Exception e, boolean isRange) {
	    fireOnInvalidSyntax(lineNumber, columnNumber, mitabColumn, isRange);
	}

	abstract Participant finishParticipant(Collection<MitabXref> uniqueId, Collection<MitabXref> altid , Collection<MitabAlias> aliases,
	                                       Collection<MitabOrganism> taxid, Collection<MitabCvTerm> bioRole, Collection<MitabCvTerm> expRole,
	                                       Collection<MitabCvTerm> type, Collection<MitabXref> xref, Collection<MitabAnnotation> annot,
	                                       Collection<MitabChecksum> checksum, Collection<MitabFeature> feature, Collection<MitabStoichiometry> stc,
	                                       Collection<MitabCvTerm> detMethod);
	abstract Interaction finishInteraction(Participant A, Participant B, Collection<MitabCvTerm> detMethod, Collection<MitabAuthor> firstAuthor,
	                                       Collection<MitabXref> pubId, Collection<MitabCvTerm> interactionType, Collection<MitabSource> source,
	                                       Collection<MitabXref> interactionId, Collection<MitabConfidence> conf, Collection<MitabCvTerm> expansion,
	                                       Collection<MitabXref> xrefI, Collection<MitabAnnotation> annotI, Collection<MitabOrganism> host,
	                                       Collection<MitabParameter> params, Collection<MitabDate> created, Collection<MitabDate> update,
	                                       Collection<MitabChecksum> checksumI, boolean isNegative);
}

PARSER_END(MitabLineParser)

/* WHITE SPACE */

SKIP :
{
  "\r" | "\f"
}

TOKEN :
{
  < UNRESERVED_STRING:
    //don't match single dash, that's an empty column
      "-" (~["\"", "|", "(", ")", ":", "\t", "\n", "-"])+
    |
      ~["\"", "|", "(", ")", ":", "\t", "\n", "-"] (~["\"", "|", "(", ")", ":", "\t", "\n"])*
    >
 |
  < QUOTED_STRING:
    "\"" 
      ( ~["\""] | ("\\" "\"") )* 
    "\""
    >
 |
  < EMPTY_COLUMN: "-" >
}

TOKEN :
{
  < PUB_DATE: (["0"-"9"]){4} >
}

TOKEN [IGNORE_CASE]:
{
 <TAXID : "taxid">
}

TOKEN [IGNORE_CASE]:
{
 <NEGATIVE : (" ")* ("true" | "false" | ("\"" "true" | "false" "\"")) (" ")* >
}

TOKEN [IGNORE_CASE]:
{
 <POSITION : (" ")* ("n" | "c" | "<" | ">" | "?" |  ["-"] (["0"-"9"])+ (" ")*) >
}

TOKEN :
{
  < STOICHIOMETRY: (["0"-"9"])+ | (["0"-"9"])+ "." (["0"-"9"])+ >
}

TOKEN :
{
  < COMMENT: "#" (~["\n"])*>
}

TOKEN :
{
  < FIELD_SEPARATOR: "|">
}

TOKEN :
{
  < COLUMN_SEPARATOR: "\t">
}

TOKEN :
{
  < LINE_SEPARATOR: "\n">
}

TOKEN :
{
  < RANGE_SEPARATOR: ",">
}

Interaction MitabLine():
{
  Collection<MitabXref> uniqueIdA;
  Collection<MitabXref> uniqueIdB;
  Collection<MitabXref> altIdA;
  Collection<MitabXref> altIdB;
  Collection<MitabAlias> aliasA;
  Collection<MitabAlias> aliasB;
  Collection<MitabCvTerm> detMethod;
  Collection<MitabAuthor> firstAuthor;
  Collection<MitabXref> pubId;
  Collection<MitabOrganism> taxidA;
  Collection<MitabOrganism> taxidB;
  Collection<MitabCvTerm> interactionType;
  Collection<MitabSource> source;
  Collection<MitabXref> interactionId;
  Collection<MitabConfidence> conf;
  Collection<MitabCvTerm> expansion;
  Collection<MitabCvTerm> bioRoleA;
  Collection<MitabCvTerm> bioRoleB;
  Collection<MitabCvTerm> expRoleA;
  Collection<MitabCvTerm> expRoleB;
  Collection<MitabCvTerm> typeA;
  Collection<MitabCvTerm> typeB;
  Collection<MitabXref> xrefA;
  Collection<MitabXref> xrefB;
  Collection<MitabXref> xrefI;
  Collection<MitabAnnotation> annotA;
  Collection<MitabAnnotation> annotB;
  Collection<MitabAnnotation> annotI;
  Collection<MitabOrganism> host;
  Collection<MitabParameter> params;
  Collection<MitabDate> created;
  Collection<MitabDate> update;
  Collection<MitabChecksum> checksumA;
  Collection<MitabChecksum> checksumB;
  Collection<MitabChecksum> checksumI;
  boolean isNegative = false;
  Collection<MitabFeature> featureA;
  Collection<MitabFeature> featureB;
  Collection<MitabStoichiometry> stcA;
  Collection<MitabStoichiometry> stcB;
  Collection<MitabCvTerm> pmethodA;
  Collection<MitabCvTerm> pmethodB;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR);
}
{
(
  try{
     //allow empty lines
    [
      ( <COMMENT> )
    |
      (
        (<EMPTY_COLUMN> {uniqueIdA = Collections.EMPTY_LIST;} | uniqueIdA = ids(CvTermUtils.createIdentityXrefQualifier(), false, 1)) "\t"
        (<EMPTY_COLUMN> {uniqueIdB = Collections.EMPTY_LIST;} | uniqueIdB = ids(CvTermUtils.createIdentityXrefQualifier(), false, 2)) "\t"
        (<EMPTY_COLUMN> {altidA = Collections.EMPTY_LIST;} | altIdA = ids(CvTermUtils.createSecondaryXrefQualifier(), false, 3)) "\t"
        (<EMPTY_COLUMN> {altidB = Collections.EMPTY_LIST;} | altIdB = ids(CvTermUtils.createSecondaryXrefQualifier(), false, 4)) "\t"
        (<EMPTY_COLUMN> {aliasA = Collections.EMPTY_LIST;} | aliasA = aliases(5)) "\t"
        (<EMPTY_COLUMN> {aliasB = Collections.EMPTY_LIST;} | aliasB = aliases(6)) "\t"
        (<EMPTY_COLUMN> {detMethod = Collections.EMPTY_LIST;} | detMethod = cvTerms(7)) "\t"
        (<EMPTY_COLUMN> {firstAuthor = Collections.EMPTY_LIST;} | firstAuthor = firstAuthors()) "\t"
        (<EMPTY_COLUMN> {pubId = Collections.EMPTY_LIST;} | pubId = ids(CvTermUtils.createIdentityXrefQualifier(), true, 9)) "\t"
        (<EMPTY_COLUMN> {taxidA = Collections.EMPTY_LIST;} | taxidA = taxId(10)) "\t"
        (<EMPTY_COLUMN> {taxidB = Collections.EMPTY_LIST;} | taxidB = taxId(11)) "\t"
        (<EMPTY_COLUMN> {interactionType = Collections.EMPTY_LIST;} | interactionType = cvTerms(12)) "\t"
        (<EMPTY_COLUMN> {source = Collections.EMPTY_LIST;} | source = sourceDbs()) "\t"
        (<EMPTY_COLUMN> {interactionId = Collections.EMPTY_LIST;} | interactionId = ids(CvTermUtils.createIdentityXrefQualifier(), true, 14)) "\t"
        (<EMPTY_COLUMN> {conf = Collections.EMPTY_LIST;} | conf = confidences())

        [ //starting MITAB 2.6
        "\t" //end of confidences delimiter
        (<EMPTY_COLUMN> {expansion = Collections.EMPTY_LIST;} | expansion = complexExpansion()) "\t"
        (<EMPTY_COLUMN> {bioRoleA = Collections.EMPTY_LIST;} | bioRoleA = cvTerms(17)) "\t"
        (<EMPTY_COLUMN> {bioRoleB = Collections.EMPTY_LIST;} | bioRoleB = cvTerms(18)) "\t"
        (<EMPTY_COLUMN> {expRoleA = Collections.EMPTY_LIST;} | expRoleA = cvTerms(19)) "\t"
        (<EMPTY_COLUMN> {expRoleB = Collections.EMPTY_LIST;} | expRoleB = cvTerms(20)) "\t"
        (<EMPTY_COLUMN> {typeA = Collections.EMPTY_LIST;} | typeA = cvTerms(21)) "\t"
        (<EMPTY_COLUMN> {typeB = Collections.EMPTY_LIST;} | typeB = cvTerms(22)) "\t"
        (<EMPTY_COLUMN> {xrefA = Collections.EMPTY_LIST;} | xrefA = ids(null, false, 23)) "\t"
        (<EMPTY_COLUMN> {xrefB = Collections.EMPTY_LIST;} | xrefB = ids(null, false, 24)) "\t"
        (<EMPTY_COLUMN> {xrefI = Collections.EMPTY_LIST;} | xrefI = ids(null, false, 25)) "\t"
        (<EMPTY_COLUMN> {annotA = Collections.EMPTY_LIST;} | annotA = annotations(26)) "\t"
        (<EMPTY_COLUMN> {annotB = Collections.EMPTY_LIST;} | annotB = annotations(27)) "\t"
        (<EMPTY_COLUMN> {annotI = Collections.EMPTY_LIST;} | annotI = annotations(28)) "\t"
        (<EMPTY_COLUMN> {host = Collections.EMPTY_LIST;} | host = taxId(29)) "\t"
        (<EMPTY_COLUMN> {params = Collections.EMPTY_LIST;} | params = parameters()) "\t"
        (<EMPTY_COLUMN> {created = Collections.EMPTY_LIST;} | created = dates(31)) "\t"
        (<EMPTY_COLUMN> {update = Collections.EMPTY_LIST;} | update = dates(32)) "\t"
        (<EMPTY_COLUMN> {checksumA = Collections.EMPTY_LIST;} | checksumA = checksums(33)) "\t"
        (<EMPTY_COLUMN> {checksumB = Collections.EMPTY_LIST;} | checksumB = checksums(34)) "\t"
        (<EMPTY_COLUMN> {checksumI = Collections.EMPTY_LIST;} | checksumI = checksums(35)) "\t"
        (<EMPTY_COLUMN> | negative = negative())

        [ //starting MITAB 2.7
        "\t" //end of negative() delimiter
        (<EMPTY_COLUMN> {featureA = Collections.EMPTY_LIST;} | featureA = features(37)) "\t"
        (<EMPTY_COLUMN> {featureB = Collections.EMPTY_LIST;} | featureB = features(38)) "\t"
        (<EMPTY_COLUMN> {stcA = Collections.EMPTY_LIST;} | stcA = stoichiometryList(39)) "\t"
        (<EMPTY_COLUMN> {stcB = Collections.EMPTY_LIST;} | stcB = stoichiometryList(40)) "\t"
        (<EMPTY_COLUMN> {pmethodA = Collections.EMPTY_LIST;} | pmethodA = cvTerms(41)) "\t"
        (<EMPTY_COLUMN> {pmethodB = Collections.EMPTY_LIST;} | pmethodB = cvTerms(42)) "\t"
        ] // end MITAB 2.7

        ] //end MITAB 2.6
      )
      {
        participantA = finishParticipant(idA, altIdA, aliasA, taxidA, bioRoleA, expRoleA, typeA, xrefA, annotA, checksumA, featureA, stcA, pmethodA);
        participantB = finishParticipant(idA, altIdB, aliasB, taxidB, bioRoleB, expRoleB, typeB, xrefB, annotB, checksumB, featureB, stcB, pmethodB);
        return finishInteraction(participantA, participantB, detMethod, firstAuthor, pubId, interactionType, source, interactionId,
                                 conf, expansion, xrefI, annotI, host, params, created, update, checksumI, isNegative);
      }
    ]

      }
      catch (ParseException e){
        processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
        error_skipToNext(enumSet);
        return Collections.EMPTY_LIST;
      }

    //line/file termination
    (
        "\n"
      |
        (<EOF>)
    )
)
  { return null; }
}

Collection<MitabXref> ids(CvTerm qualifier, boolean recognizeImex, int column):
{
  Collection<MitabXref> xrefs;
  MitabXref var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
      var = id(qualifier, recognizeImex, column)
         {xrefs = new ArrayList<MitabXref>(); if (var != null) {xrefs.add(var);}}

    ("|" var = id(qualifier, recognizeImex, column) {if (var != null) {xrefs.add(var);}})*
    {return xrefs;}
  }
  catch (ParseException e){
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
      error_skipToNext(enumSet);
       return Collections.EMPTY_LIST;
    }
}

Collection<MitabAlias> aliases(int column):
{
  Collection<MitabAlias> aliases;
  MitabAlias var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = alias(column)
    {aliases = new ArrayList<MitabAlias>(); if (var != null) {if (var != null) {aliases.add(var);}}}

    ("|" var = alias(column) {if (var != null) {if (var != null) {aliases.add(var);}}})*
    {return aliases;}
  }
  catch (ParseException e){
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
      error_skipToNext(enumSet);
       return Collections.EMPTY_LIST;
    }
}

Collection<MitabCvterm> cvTerms(int columnNumber):
{
  Collection<MitabCvterm> methods;
  MitabCvTerm var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
  var = cvTerm(columnNumber)
    {methods = new ArrayList<MitabCvterm>(); if (var != null) {methods.add(var);}}

    ("|" var = cvTerm(columnNumber) {if (var != null) {methods.add(var);}})*
    {return methods;}
  }
  catch (ParseException e){
    processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
    error_skipToNext(enumSet);
     return Collections.EMPTY_LIST;
  }
}

Collection<MitabAuthor> firstAuthors():
{
  Collection<MitabAuthor> authors;
  MitabAuthor var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = author()
    {authors = new ArrayList<MitabAuthor>(); if (var != null) {authors.add(var);}}

    ("|" var = author() {if (var != null) {authors.add(var);}})*
    {return authors;}
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, 8, e, false);
        error_skipToNext(enumSet);
        return Collections.EMPTY_LIST;
     }
}

Collection<MitabOrganism> taxId(int column):
{
  Collection<MitabOrganism> organisms;
  MitabOrganism var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = organism(column)
    {organisms = new ArrayList<MitabOrganism>(); if (var != null) {organisms.add(var);}}

    ("|" var = organism(column) {if (var != null) {organisms.add(var);}})*
    {return organisms;}
  }
  catch (ParseException e){
         processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
         error_skipToNext(enumSet);
         return Collections.EMPTY_LIST;
      }
}

Collection<MitabSource> sourceDbs():
{
  Collection<MitabSource> sources;
  MitabSource var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
     var = source()
    {sources = new ArrayList<MitabSource>(); if (var != null) {sources.add(var);}}

    ("|" var = source() {if (var != null) {sources.add(var);}})*
    {return sources;}
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, 13, e, false);
       error_skipToNext(enumSet);
       return Collections.EMPTY_LIST;
    }
}

Collection<MitabConfidence> confidences():
{
  Collection<MitabConfidence> confs;
  MitabConfidence var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = confidence()
    {confs = new ArrayList<MitabConfidence>(); if (var != null) {confs.add(var);}}

    ("|" var = confidence() {if (var != null) {confs.add(var);}})*
    {return confs;}
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, 15, e, false);
       error_skipToNext(enumSet);
       return Collections.EMPTY_LIST;
    }
}

Collection<MitabCvTerm> complexExpansion():
{
  Collection<MitabCvterm> expansions;
  MitabCvTerm var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = expansion()
    {expansions = new ArrayList<MitabCvterm>(); if (var != null) {expansions.add(var);}}

    ("|" var = expansion() {if (var != null) {expansions.add(var);}})*
    {return expansions;}
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, 16, e, false);
     error_skipToNext(enumSet);
     return Collections.EMPTY_LIST;
  }
}

Collection<MitabAnnotation> annotations(int column):
{
  Collection<MitabAnnotation> annots;
  MitabAnnotation var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = annotation(column)
      {annots = new ArrayList<MitabAnnotation>(); if (var != null) {annots.add(var);}}

      ("|" var = annotation(column) {if (var != null) {annots.add(var);}})*
      {return annots;}
  }
  catch (ParseException e){
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
      error_skipToNext(enumSet);
      return Collections.EMPTY_LIST;
  }
}

Collection<MitabParameter> parameters():
{
  Collection<MitabParameter> params;
  MitabParameter var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = parameter(column)
    {params = new ArrayList<MitabParameter>(); if (var != null) {params.add(var);}}

    ("|" var = parameter(column) {if (var != null) {params.add(var);}})*
    {return params;}
  }
  catch (ParseException e){
         processSyntaxError(token.beginLine, token.beginColumn, 30, e, false);
         error_skipToNext(enumSet);
         return Collections.EMPTY_LIST;
      }
}

Collection<MitabDate> dates(int column):
{
  Collection<MitabDate> dates;
  MitabDate var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = date(column)
      {dates = new ArrayList<MitabDate>(); if (var != null) {if (var != null) {dates.add(var);}}}

      ("|" var = date(column) {if (var != null) {if (var != null) {if (var != null) {dates.add(var);}}}})*
      {return dates;}
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
       error_skipToNext(enumSet);
       return Collections.EMPTY_LIST;
    }
}

Collection<MitabChecksum> checksums(int column):
{
  Collection<MitabChecksum> checksums;
  MitabChecksum var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
      var = checksum(column)
      {checksums = new ArrayList<MitabChecksum>(); if (var != null) {checksums.add(var);}}

      ("|" var = checksum(column) {if (var != null) {checksums.add(var);}})*
      {return checksums;}
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
     error_skipToNext(enumSet);
     return Collections.EMPTY_LIST;
  }
}

Collection<MitabFeature> features(int column):
{
  Collection<MitabFeature> features;
  MitabFeature var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
       var = feature(column)
       {features = new ArrayList<MitabFeature>(); if (var != null) {features.add(var);}}

       ("|" var = feature(column) {if (var != null) {features.add(var);}})*
       {return features;}
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
       error_skipToNext(enumSet);
       return Collections.EMPTY_LIST;
    }
}

Collection<MitabStoichiometry> stoichiometryList(int column):
{
  Collection<MitabStoichiometry> stc;
  MitabStoichiometry var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = stoichiometry(column)
    {stc = new ArrayList<MitabStoichiometry>(); if (var != null) {stc.add(var);}}

    ("|" var = stoichiometry(column) {if (var != null) {stc.add(var);}})*
    {return stc;}
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
     error_skipToNext(enumSet);
     return Collections.EMPTY_LIST;
  }
}

MitabStoichiometry stoichiometry():
{
  long min;
  java.lang.Long max = 0;
  int beginLine;
  int beginColumn;
  MitabStoichiometry stc;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //float
    <STOICHIOMETRY>
    {
        min = Long.parseLong(token.image.trim());
        beginLine = token.beginLine;
        beginColumn = token.beginColumn;
      }
      [ "-" <STOICHIOMETRY>
      {
            max = Long.parseLong(token.image.trim());
      }
      ]
      {
         if (max != null){
            stc = new MitabStoichiometry(min, max);
         }
         else{
            stc = new MitabStoichiometry(min);
         }
         stc.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
         return stc;
      }
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
        error_skipToNext(enumSet);
        return null;
   }
   catch(NumberFormatException e){
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
       error_skipToNext(enumSet);
       return null;
   }
}

MitabFeature feature(int columnNumber):
{
  java.lang.String type;
  Collection<Range> ranges;
  Range var;
  java.lang.String text;
  MitabFeature feature;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //type:range1,range2(text)
    type = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <RANGE_SEPARATOR> var = range(columnNumber)
    {ranges = new ArrayList<Range>(); if (var != null) {ranges.add(var);}}
    ("," var = range(columnNumber) {if (var != null) {ranges.add(var);}})* [ text = safeString() ]
    {
        feature = new MitabFeature(type);
        feature.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        feature.addAll(ranges);

        return feature;
      }
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
      error_skipToNext(enumSet);
      return null;
  }
}

MitabRange range(int columnNumber):
{
  Position start;
  Position end;
  MitabRange range;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.RANGE_SEPARATOR, TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{

    //x-x
    <POSITION>
    { beginLine = token.beginLine; beginColumn = token.beginColumn;
      start = PositionUtils.createPositionFromString(token.image.trim());
      start.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
    }
    "-" <POSITION>
    {
    end = PositionUtils.createPositionFromString(token.image.trim());
    end.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));

     range = new MitabRange(start, end);
     range.setSourceLocator(start.getSourceLocator());
     return range;
     }
  }
  catch (ParseException e){
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, true);
      error_skipToNext(enumSet);
      return null;
    }
   catch(IllegalRangeException e){
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, true);
       error_skipToNext(enumSet);
       start = null;
   }
}

boolean negative():
{
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
  //false or true
    <NEGATIVE>
    {
        return Boolean.parseBoolean(token.image.trim());
      }
  }
  catch (ParseException e){
    processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
     error_skipToNext(enumSet);
     return null;
  }
}

MitabChecksum checksum(int columnNumber):
{
  java.lang.String method;
  java.lang.String value;
  MitabChecksum checksum;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //method:value
    method = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} ":" value = safeString()
    {
        method = new MitabChecksum(method, value);
        method.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        return checksum;
      }
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
       error_skipToNext(enumSet);
        return null;
    }
}

MitabDate date(int columnNumber):
{
  java.lang.String date;
  MitabDate mitabDate;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //yyyy/mm/dd
    date = safeString()
    { mitabDate = new MitabDate(date);
        mitabDate.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
        return mitabDate;
     }
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
     error_skipToNext(enumSet);
      return null;
  }
  catch (java.text.ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
     error_skipToNext(enumSet);
     return null;
  }
}

MitabAnnotation parameter() :
{
  java.lang.String type;
  java.lang.String value;
  java.lang.String unit = null;
  MitabParameter param;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //type:value(unit)
    type = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} ":" value = safeString() [ "(" unit = safeString() ")" ]
    {param = new MitabParameter(type, value, unit);
     param.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 30));
     return param;
     }
  }
  catch (ParseException e){
      processSyntaxError(token.beginLine, token.beginColumn, 30, e, false);
       error_skipToNextField();
       return null;
   }
   catch (IllegalParameterException e){
      processSyntaxError(token.beginLine, token.beginColumn, 30, e, false);
      error_skipToNext(enumSet);
      return null;
    }
}

MitabAnnotation annotation(int columnNumber):
{
  java.lang.String topic;
  java.lang.String value = null;
  MitabAnnotation annot;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //topic:value
    topic = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} [ ":" value = safeString() ]
    { annot = new MitabAnnotation(topic, value);
      annot.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
      return annot;}
  }
  catch (ParseException e){
         processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
         error_skipToNext(enumSet);
         return null;
      }
}

MitabXref xref(int columnNumber):
{
  java.lang.String db;
  java.lang.String id;
  java.lang.String text = null;
  MitabXref ref;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //db:id(qualifier)
    db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} ":" id = safeString() [ "(" text = safeString() ")" ]
    { ref = new MitabXref(db, id, text);
      ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
      return ref;}
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
       error_skipToNext(enumSet);
       return null;
    }
}

MitabCvTerm expansion():
{
  java.lang.String db = null;
  java.lang.String id = null;
  java.lang.String name = null;
  MitabCvTerm cv;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
  //db:id(name) or just name for backward compatibility
    db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} ":" id = safeString() [ "(" name = safeString() ")" ]
    { if (name == null){cv = new MitabCvTerm(MitabWriterUtils.UNKNOWN_DATABASE, null, db, id); getParserListener().onMissingCvTermName(beginLine, beginColumn, 16);}
      else if (id == null) {cv = new MitabCvTerm(name); getParserListener().onMissingExpansionId(beginLine, beginColumn, 16);}
      else {cv = new MitabCvTerm(name, null, db, id);}
      cv.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 16));
      return cv;}
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, 16, e, false);
     error_skipToNext(enumSet);
     return null;
  }
}

MitabConfidence confidence():
{
 java.lang.String type;
 java.lang.String value;
 java.lang.String text = null;
  MitabConfidence conf;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    type = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} ":" value = safeString() [ "(" text = safeString() ")" ]
    { if (text == null){conf = new MitabConfidence(type, value, null);}
      else {conf = new MitabConfidence(type, value, text); getParserListener().onTextFoundInConfidence(beginLine, beginColumn, 15);}
      conf.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 15));
      return conf;}
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, 15, e, false);
     error_skipToNext(enumSet);
     return null;
  }
}

MitabSource source():
{
  java.lang.String db;
  java.lang.String id;
  java.lang.String name = null;
  MitabSource s;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try {
     //db:id(name)
       db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} ":" id = safeString() [ "(" name = safeString() ")" ]
       { if (name == null){s = new MitabSource(MitabWriterUtils.UNKNOWN_DATABASE, null, db, id); getParserListener().onMissingCvTermName(beginLine, beginColumn, 13);}
         else {s = new MitabSource(name, null, db, id);}
         s.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 13));
         return s;}
  }
  catch (ParseException e){
        processSyntaxError(token.beginLine, token.beginColumn, 13, e, false);
        error_skipToNext(enumSet);
        return null;
  }
}

MitabOrganism organism(int columnNumber):
{
  java.lang.String id;
  java.lang.String name = null;
  MitabOrganism organism;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try {
  //taxid:id(name)
    [(" ")+] <TAXID> ":" id = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} [ "(" name = safeString() ")" ]
    {
       organism = new MitabOrganism(Integer.parseInt(id), name);
       organism.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       return organism;
     }
  }
  catch (ParseException e){
           processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
           error_skipToNext(enumSet);
           return null;
  }
  catch (NumberFormatException e){
           processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
           error_skipToNext(enumSet);
           return null;
  }
}

MitabAuthor author():
{
 MitabAuthor auth;
 java.lang.String first;
 java.lang.String date = null;
 java.lang.String second;
 int beginLine;
 int beginColumn;
 EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
     ( <PUB_DATE> {date = token.image.trim(); beginLine = token.beginLine; beginColumn = token.beginColumn;} [ first = safeString() ])
     | ( first = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} [ ( (<PUB_DATE> {date = token.image.trim();}) | ("(" (" ")* <PUB_DATE> {date = token.image.trim();} (" ")* ")") [ second = safeString() {first = first + " " +second; } ]) ])
     { beginLine = token.beginLine; beginColumn = token.beginColumn;
       if (date == null){auth = new MitabAuthor(first);}
       else{ auth = new MitabAuthor(first, date);}
       auth.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 8));
       return auth;
      }
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, 8, e, false);
       error_skipToNext(enumSet);
       return null;
  }
}

MitabCvTerm cvTerm(int column):
{
  java.lang.String db;
  java.lang.String id = null;
  java.lang.String name = null;
  int beginLine;
  int beginColumn;
  MitabCvTerm cv;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  //db:id(name)
  try{
    db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} ":" id = safeString() [ "(" name = safeString() ")" ]
    { if (name == null){cv = new MitabCvTerm(MitabWriterUtils.UNKNOWN_DATABASE, null, db, id); getParserListener().onMissingCvTermName(token.beginLine, token.beginColumn, column);}
      else {cv = new MitabCvTerm(name, null, db, id);}
      cv.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, column));
      return cv;}
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, column, e, false);
     error_skipToNext(enumSet);
     return null;
  }
}

MitabAlias alias(int columnNumber):
{
  java.lang.String db;
  java.lang.String name;
  java.lang.String type = null;
  int beginLine;
  int beginColumn;
  MitabAlias alias;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  //db:name(type)
  try{
      db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} ":" name = safeString() [ "(" type = safeString() ")" ]
      { alias = new MitabAlias(db, name, type);
        alias.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        error_skipToNext(enumSet);
        return alias;}
  }
  catch(ParseException e){
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
      error_skipToNext(enumSet);
      return null;
  }
}

MitabXref id(CvTerm qualifier, boolean recognizeImexPrimary, int columnNumber):
{
  java.lang.String db;
  java.lang.String id;
  java.lang.String text = null;
  int beginLine;
  int beginColumn;
  MitabXref ref;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
  //db:id(qualifier)
    db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} ":" id = safeString() [ "(" text = safeString() ")" ]
    { if (recognizeImexPrimary && Xref.IMEX.equalsIgnoreCase(db.trim())){
         if (text == null){ref = new MitabXref(db, id, CvTermUtils.createImexPrimaryQualifier());}
         else if (qualifier != null) {ref = new MitabXref(db, id, text); getParserListener().onTextFoundInIdentifier(beginLine, beginColumn, columnNumber);}
         else {ref = new MitabXref(db, id, text);}
       }
       else if (text == null) {
         ref = new MitabXref(db, id, qualifier);
       }
       else if (qualifier != null) {
          ref = new MitabXref(db, id, text); getParserListener().onTextFoundInIdentifier(beginLine, beginColumn, columnNumber);
       }
       else{
          ref = new MitabXref(db, id, text);
       }
       ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       return ref;}
   }
   catch(ParseException e){
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e, false);
      error_skipToNext(enumSet);
      return null;
   }
}

java.lang.String safeString():
{java.lang.String text;}
{
  <QUOTED_STRING> {text = MitabWriterUtils.unescapeDoubleQuote(token.image.substring(1, token.image.length()).trim());} | <UNRESERVED_STRING> {text = token.image.trim();}
  {return text;}
}

JAVACODE
void error_skipToNext(EnumSet<TokenKind> skipToTokens) {
  ParseException e = generateParseException();  // generate the exception object.
  System.out.println(e.toString());  // print the error message

  Token t;
  // next token is 1
  int i = 1;
  do {
    t = getNextToken();
    // check next token
    i++;
    t = getToken(i);
  } while (t != null && !skipToTokens.contains(TokenKind.getFromTokenKind(t.kind)));
    // The above loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
    // "if"/"while".
}