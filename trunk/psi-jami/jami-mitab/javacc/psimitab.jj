
options {
  LOOKAHEAD = 1;
  FORCE_LA_CHECK = true;
  JAVA_UNICODE_ESCAPE = true;
  STATIC = false;
  CHOICE_AMBIGUITY_CHECK = 5;
  OTHER_AMBIGUITY_CHECK = 5;
}

PARSER_BEGIN(MitabLineParser)
package psidev.psi.mi.jami.tab.io.parser;

import psidev.psi.mi.jami.model.*;
import psidev.psi.mi.jami.tab.extension.*;
import psidev.psi.mi.jami.tab.listener.MitabParserListener;
import java.util.Collection;
import java.util.Collections;
import psidev.psi.mi.jami.utils.CvTermUtils;
import psidev.psi.mi.jami.utils.PositionUtils;
import java.util.ArrayList;
import java.util.EnumSet;
import java.lang.NumberFormatException;
import psidev.psi.mi.jami.exception.IllegalParameterException;
import psidev.psi.mi.jami.exception.IllegalRangeException;
import psidev.psi.mi.jami.tab.utils.MitabUtils;

public abstract class MitabLineParser<T extends Interaction, P extends Participant> {
	
	void processSyntaxError(int lineNumber, int columnNumber, int mitabColumn, Exception e) {
	    fireOnInvalidSyntax(lineNumber, columnNumber, mitabColumn, e);
	}

	public abstract MitabParserListener getParserListener();

	public abstract void setParserListener(MitabParserListener listener);

    abstract void fireOnInvalidSyntax(int lineNumber, int columnNumber, int mitabColumn, Exception e);

    abstract void reachEndOfFile();

    public abstract boolean hasFinished();

	abstract P finishParticipant(Collection<MitabXref> uniqueId, Collection<MitabXref> altid , Collection<MitabAlias> aliases,
	                                       Collection<MitabOrganism> taxid, Collection<MitabCvTerm> bioRole, Collection<MitabCvTerm> expRole,
	                                       Collection<MitabCvTerm> type, Collection<MitabXref> xref, Collection<MitabAnnotation> annot,
	                                       Collection<MitabChecksum> checksum, Collection<MitabFeature> feature, Collection<MitabStoichiometry> stc,
	                                       Collection<MitabCvTerm> detMethod, int line, int column, int mitabColumn);
	abstract T finishInteraction(P A, P B, Collection<MitabCvTerm> detMethod, Collection<MitabAuthor> firstAuthor,
	                                       Collection<MitabXref> pubId, Collection<MitabCvTerm> interactionType, Collection<MitabSource> source,
	                                       Collection<MitabXref> interactionId, Collection<MitabConfidence> conf, Collection<MitabCvTerm> expansion,
	                                       Collection<MitabXref> xrefI, Collection<MitabAnnotation> annotI, Collection<MitabOrganism> host,
	                                       Collection<MitabParameter> params, Collection<MitabDate> created, Collection<MitabDate> update,
	                                       Collection<MitabChecksum> checksumI, boolean isNegative, int line);
}

PARSER_END(MitabLineParser)

/* WHITE SPACE */

SKIP :
{
  "\r" | "\f"
}

TOKEN :
{
  < RANGE_SEPARATOR: ",">
}

TOKEN :
{
  < PUB_DATE: (["0"-"9"]){4} >
  | <NUMBER: (["0"-"9"])+>
  | < STOICHIOMETRY: (["0"-"9"])+ "." (["0"-"9"])+ >
  | < COMMENT: "#" (~["\n"])*>
  | < FIELD_SEPARATOR: "|">
  | < COLUMN_SEPARATOR: "\t">
  | < LINE_SEPARATOR: "\n">
  | < OPEN_PAREN: "(">
  | < CLOSE_PAREN: ")">
  | < COLON: ":">
  | < DASH: "-" >
  | < LESSTHAN: "<" >
  | < GREATERTHAN: ">" >
}

TOKEN [IGNORE_CASE]:
{
 <POSITION : "n" | "c" | "?" >
 | <TAXID : "taxid">
 | < NEGATIVE : ("true" | "false" | ("\"" "true" | "false" "\"")) >
}

TOKEN :
{
  < QUOTED_STRING:
    "\"" 
      ( ~["\""] | ("\\" "\"") )* 
    "\""
    >
 |
  < ANY_CHAR: ~[] >
}

T MitabLine():
{
  Collection<MitabXref> uniqueIdA;
  Collection<MitabXref> uniqueIdB;
  Collection<MitabXref> altIdA;
  Collection<MitabXref> altIdB;
  Collection<MitabAlias> aliasA;
  Collection<MitabAlias> aliasB;
  Collection<MitabCvTerm> detMethod;
  Collection<MitabAuthor> firstAuthor;
  Collection<MitabXref> pubId;
  Collection<MitabOrganism> taxidA;
  Collection<MitabOrganism> taxidB;
  Collection<MitabCvTerm> interactionType;
  Collection<MitabSource> source;
  Collection<MitabXref> interactionId;
  Collection<MitabConfidence> conf;
  Collection<MitabCvTerm> expansion = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> bioRoleA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> bioRoleB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> expRoleA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> expRoleB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> typeA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> typeB = Collections.EMPTY_LIST;
  Collection<MitabXref> xrefA = Collections.EMPTY_LIST;
  Collection<MitabXref> xrefB = Collections.EMPTY_LIST;
  Collection<MitabXref> xrefI = Collections.EMPTY_LIST;
  Collection<MitabAnnotation> annotA = Collections.EMPTY_LIST;
  Collection<MitabAnnotation> annotB = Collections.EMPTY_LIST;
  Collection<MitabAnnotation> annotI = Collections.EMPTY_LIST;
  Collection<MitabOrganism> host = Collections.EMPTY_LIST;
  Collection<MitabParameter> params = Collections.EMPTY_LIST;
  Collection<MitabDate> created = Collections.EMPTY_LIST;
  Collection<MitabDate> update = Collections.EMPTY_LIST;
  Collection<MitabChecksum> checksumA = Collections.EMPTY_LIST;
  Collection<MitabChecksum> checksumB = Collections.EMPTY_LIST;
  Collection<MitabChecksum> checksumI = Collections.EMPTY_LIST;
  boolean isNegative = false;
  Collection<MitabFeature> featureA = Collections.EMPTY_LIST;
  Collection<MitabFeature> featureB = Collections.EMPTY_LIST;
  Collection<MitabStoichiometry> stcA = Collections.EMPTY_LIST;
  Collection<MitabStoichiometry> stcB = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> pmethodA = Collections.EMPTY_LIST;
  Collection<MitabCvTerm> pmethodB = Collections.EMPTY_LIST;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR);
  P participantA;
  P participantB;
  T interaction=null;
  int line;
  int columnA;
  int columnB;
}
{
(
  try{
     //allow empty lines
    [
      ( <COMMENT> )
    |
      (
        (<DASH> {uniqueIdA = Collections.EMPTY_LIST; line = token.beginLine; columnA = token.beginColumn;} | uniqueIdA = ids(CvTermUtils.createIdentityXrefQualifier(), false, 1)) {line = token.beginLine; columnA = token.beginColumn;} <COLUMN_SEPARATOR>
        (<DASH> {uniqueIdB = Collections.EMPTY_LIST; columnB = token.beginColumn;} | uniqueIdB = ids(CvTermUtils.createIdentityXrefQualifier(), false, 2)) {columnB = token.beginColumn;} <COLUMN_SEPARATOR>
        (<DASH> {altIdA = Collections.EMPTY_LIST;} | altIdA = ids(CvTermUtils.createSecondaryXrefQualifier(), false, 3)) <COLUMN_SEPARATOR>
        (<DASH> {altIdB = Collections.EMPTY_LIST;} | altIdB = ids(CvTermUtils.createSecondaryXrefQualifier(), false, 4)) <COLUMN_SEPARATOR>
        (<DASH> {aliasA = Collections.EMPTY_LIST;} | aliasA = aliases(5)) <COLUMN_SEPARATOR>
        (<DASH> {aliasB = Collections.EMPTY_LIST;} | aliasB = aliases(6)) <COLUMN_SEPARATOR>
        (<DASH> {detMethod = Collections.EMPTY_LIST;} | detMethod = cvTerms(7)) <COLUMN_SEPARATOR>
        (<DASH> {firstAuthor = Collections.EMPTY_LIST;} | firstAuthor = firstAuthors()) <COLUMN_SEPARATOR>
        (<DASH> {pubId = Collections.EMPTY_LIST;} | pubId = ids(CvTermUtils.createIdentityXrefQualifier(), true, 9)) <COLUMN_SEPARATOR>
        (<DASH> {taxidA = Collections.EMPTY_LIST;} | taxidA = taxId(10)) <COLUMN_SEPARATOR>
        (<DASH> {taxidB = Collections.EMPTY_LIST;} | taxidB = taxId(11)) <COLUMN_SEPARATOR>
        (<DASH> {interactionType = Collections.EMPTY_LIST;} | interactionType = cvTerms(12)) <COLUMN_SEPARATOR>
        (<DASH> {source = Collections.EMPTY_LIST;} | source = sourceDbs()) <COLUMN_SEPARATOR>
        (<DASH> {interactionId = Collections.EMPTY_LIST;} | interactionId = ids(CvTermUtils.createIdentityXrefQualifier(), true, 14)) <COLUMN_SEPARATOR>
        (<DASH> {conf = Collections.EMPTY_LIST;} | conf = confidences())

        [ //starting MITAB 2.6
        <COLUMN_SEPARATOR> //end of confidences delimiter
        (<DASH> {expansion = Collections.EMPTY_LIST;} | expansion = complexExpansion()) <COLUMN_SEPARATOR>
        (<DASH> {bioRoleA = Collections.EMPTY_LIST;} | bioRoleA = cvTerms(17)) <COLUMN_SEPARATOR>
        (<DASH> {bioRoleB = Collections.EMPTY_LIST;} | bioRoleB = cvTerms(18)) <COLUMN_SEPARATOR>
        (<DASH> {expRoleA = Collections.EMPTY_LIST;} | expRoleA = cvTerms(19)) <COLUMN_SEPARATOR>
        (<DASH> {expRoleB = Collections.EMPTY_LIST;} | expRoleB = cvTerms(20)) <COLUMN_SEPARATOR>
        (<DASH> {typeA = Collections.EMPTY_LIST;} | typeA = cvTerms(21)) <COLUMN_SEPARATOR>
        (<DASH> {typeB = Collections.EMPTY_LIST;} | typeB = cvTerms(22)) <COLUMN_SEPARATOR>
        (<DASH> {xrefA = Collections.EMPTY_LIST;} | xrefA = ids(null, false, 23)) <COLUMN_SEPARATOR>
        (<DASH> {xrefB = Collections.EMPTY_LIST;} | xrefB = ids(null, false, 24)) <COLUMN_SEPARATOR>
        (<DASH> {xrefI = Collections.EMPTY_LIST;} | xrefI = ids(null, false, 25)) <COLUMN_SEPARATOR>
        (<DASH> {annotA = Collections.EMPTY_LIST;} | annotA = annotations(26)) <COLUMN_SEPARATOR>
        (<DASH> {annotB = Collections.EMPTY_LIST;} | annotB = annotations(27)) <COLUMN_SEPARATOR>
        (<DASH> {annotI = Collections.EMPTY_LIST;} | annotI = annotations(28)) <COLUMN_SEPARATOR>
        (<DASH> {host = Collections.EMPTY_LIST;} | host = taxId(29)) <COLUMN_SEPARATOR>
        (<DASH> {params = Collections.EMPTY_LIST;} | params = parameters()) <COLUMN_SEPARATOR>
        (<DASH> {created = Collections.EMPTY_LIST;} | created = dates(31)) <COLUMN_SEPARATOR>
        (<DASH> {update = Collections.EMPTY_LIST;} | update = dates(32)) <COLUMN_SEPARATOR>
        (<DASH> {checksumA = Collections.EMPTY_LIST;} | checksumA = checksums(33)) <COLUMN_SEPARATOR>
        (<DASH> {checksumB = Collections.EMPTY_LIST;} | checksumB = checksums(34)) <COLUMN_SEPARATOR>
        (<DASH> {checksumI = Collections.EMPTY_LIST;} | checksumI = checksums(35)) <COLUMN_SEPARATOR>
        (<DASH> | isNegative = negative())

        [ //starting MITAB 2.7
        <COLUMN_SEPARATOR> //end of negative() delimiter
        (<DASH> {featureA = Collections.EMPTY_LIST;} | featureA = features(37)) <COLUMN_SEPARATOR>
        (<DASH> {featureB = Collections.EMPTY_LIST;} | featureB = features(38)) <COLUMN_SEPARATOR>
        (LOOKAHEAD(2) <DASH> {stcA = Collections.EMPTY_LIST;} | stcA = stoichiometryList(39)) <COLUMN_SEPARATOR>
        (LOOKAHEAD(2) <DASH> {stcB = Collections.EMPTY_LIST;} | stcB = stoichiometryList(40)) <COLUMN_SEPARATOR>
        (<DASH> {pmethodA = Collections.EMPTY_LIST;} | pmethodA = cvTerms(41)) <COLUMN_SEPARATOR>
        (<DASH> {pmethodB = Collections.EMPTY_LIST;} | pmethodB = cvTerms(42))
        ] // end MITAB 2.7

        ] //end MITAB 2.6
      )
      {
        participantA = finishParticipant(uniqueIdA, altIdA, aliasA, taxidA, bioRoleA, expRoleA, typeA, xrefA, annotA, checksumA, featureA, stcA, pmethodA, line, columnA, 1);
        participantB = finishParticipant(uniqueIdB, altIdB, aliasB, taxidB, bioRoleB, expRoleB, typeB, xrefB, annotB, checksumB, featureB, stcB, pmethodB, line, columnB, 2);
        interaction = finishInteraction(participantA, participantB, detMethod, firstAuthor, pubId, interactionType, source, interactionId,
                                 conf, expansion, xrefI, annotI, host, params, created, update, checksumI, isNegative, line);
      }
    ]

      }
      catch (ParseException e){
        processSyntaxError(token.beginLine, token.beginColumn, 0, e);
        error_skipToNext(enumSet);
        return null;
      }

    //line/file termination
    (
        <LINE_SEPARATOR> {return interaction;}
      |
      (<EOF> {reachEndOfFile(); return interaction;})
      |
      error_skipToNext(enumSet) {return interaction;}
    )
)
  { return interaction; }
}

Collection<MitabXref> ids(CvTerm qualifier, boolean recognizeImex, int column):
{
  Collection<MitabXref> xrefs;
  MitabXref var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
      var = id(qualifier, recognizeImex, column)
         {xrefs = new ArrayList<MitabXref>(); if (var != null) {xrefs.add(var);}}

    (<FIELD_SEPARATOR> var = id(qualifier, recognizeImex, column) {if (var != null) {xrefs.add(var);}})*
    {return xrefs;}
  }
  catch (ParseException e){
      processSyntaxError(token.beginLine, token.beginColumn, column, e);
      error_skipToNext(enumSet);
       return Collections.EMPTY_LIST;
    }
}

Collection<MitabAlias> aliases(int column):
{
  Collection<MitabAlias> aliases;
  MitabAlias var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = alias(column)
    {aliases = new ArrayList<MitabAlias>(); if (var != null) {if (var != null) {aliases.add(var);}}}

    (<FIELD_SEPARATOR> var = alias(column) {if (var != null) {if (var != null) {aliases.add(var);}}})*
    {return aliases;}
  }
  catch (ParseException e){
      processSyntaxError(token.beginLine, token.beginColumn, column, e);
      error_skipToNext(enumSet);
       return Collections.EMPTY_LIST;
    }
}

Collection<MitabCvTerm> cvTerms(int columnNumber):
{
  Collection<MitabCvTerm> methods;
  MitabCvTerm var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
  var = cvTerm(columnNumber)
    {methods = new ArrayList<MitabCvTerm>(); if (var != null) {methods.add(var);}}

    (<FIELD_SEPARATOR> var = cvTerm(columnNumber) {if (var != null) {methods.add(var);}})*
    {return methods;}
  }
  catch (ParseException e){
    processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
    error_skipToNext(enumSet);
     return Collections.EMPTY_LIST;
  }
}

Collection<MitabAuthor> firstAuthors():
{
  Collection<MitabAuthor> authors;
  MitabAuthor var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = author()
    {authors = new ArrayList<MitabAuthor>(); if (var != null) {authors.add(var);}}

    (<FIELD_SEPARATOR> var = author() {if (var != null) {authors.add(var);}})*
    {return authors;}
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, 8, e);
        error_skipToNext(enumSet);
        return Collections.EMPTY_LIST;
     }
}

Collection<MitabOrganism> taxId(int column):
{
  Collection<MitabOrganism> organisms;
  MitabOrganism var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = organism(column)
    {organisms = new ArrayList<MitabOrganism>(); if (var != null) {organisms.add(var);}}

    (<FIELD_SEPARATOR> var = organism(column) {if (var != null) {organisms.add(var);}})*
    {return organisms;}
  }
  catch (ParseException e){
         processSyntaxError(token.beginLine, token.beginColumn, column, e);
         error_skipToNext(enumSet);
         return Collections.EMPTY_LIST;
      }
}

Collection<MitabSource> sourceDbs():
{
  Collection<MitabSource> sources;
  MitabSource var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
     var = source()
    {sources = new ArrayList<MitabSource>(); if (var != null) {sources.add(var);}}

    (<FIELD_SEPARATOR> var = source() {if (var != null) {sources.add(var);}})*
    {return sources;}
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, 13, e);
       error_skipToNext(enumSet);
       return Collections.EMPTY_LIST;
    }
}

Collection<MitabConfidence> confidences():
{
  Collection<MitabConfidence> confs;
  MitabConfidence var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = confidence()
    {confs = new ArrayList<MitabConfidence>(); if (var != null) {confs.add(var);}}

    (<FIELD_SEPARATOR> var = confidence() {if (var != null) {confs.add(var);}})*
    {return confs;}
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, 15, e);
       error_skipToNext(enumSet);
       return Collections.EMPTY_LIST;
    }
}

Collection<MitabCvTerm> complexExpansion():
{
  Collection<MitabCvTerm> expansions;
  MitabCvTerm var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = expansion()
    {expansions = new ArrayList<MitabCvTerm>(); if (var != null) {expansions.add(var);}}

    (<FIELD_SEPARATOR> var = expansion() {if (var != null) {expansions.add(var);}})*
    {return expansions;}
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, 16, e);
     error_skipToNext(enumSet);
     return Collections.EMPTY_LIST;
  }
}

Collection<MitabAnnotation> annotations(int column):
{
  Collection<MitabAnnotation> annots;
  MitabAnnotation var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = annotation(column)
      {annots = new ArrayList<MitabAnnotation>(); if (var != null) {annots.add(var);}}

      (<FIELD_SEPARATOR> var = annotation(column) {if (var != null) {annots.add(var);}})*
      {return annots;}
  }
  catch (ParseException e){
      processSyntaxError(token.beginLine, token.beginColumn, column, e);
      error_skipToNext(enumSet);
      return Collections.EMPTY_LIST;
  }
}

Collection<MitabParameter> parameters():
{
  Collection<MitabParameter> params;
  MitabParameter var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = parameter()
    {params = new ArrayList<MitabParameter>(); if (var != null) {params.add(var);}}

    (<FIELD_SEPARATOR> var = parameter() {if (var != null) {params.add(var);}})*
    {return params;}
  }
  catch (ParseException e){
         processSyntaxError(token.beginLine, token.beginColumn, 30, e);
         error_skipToNext(enumSet);
         return Collections.EMPTY_LIST;
      }
}

Collection<MitabDate> dates(int column):
{
  Collection<MitabDate> dates;
  MitabDate var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = date(column)
      {dates = new ArrayList<MitabDate>(); if (var != null) {if (var != null) {dates.add(var);}}}

      (<FIELD_SEPARATOR> var = date(column) {if (var != null) {if (var != null) {if (var != null) {dates.add(var);}}}})*
      {return dates;}
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, column, e);
       error_skipToNext(enumSet);
       return Collections.EMPTY_LIST;
    }
}

Collection<MitabChecksum> checksums(int column):
{
  Collection<MitabChecksum> checksums;
  MitabChecksum var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
      var = checksum(column)
      {checksums = new ArrayList<MitabChecksum>(); if (var != null) {checksums.add(var);}}

      (<FIELD_SEPARATOR> var = checksum(column) {if (var != null) {checksums.add(var);}})*
      {return checksums;}
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, column, e);
     error_skipToNext(enumSet);
     return Collections.EMPTY_LIST;
  }
}

Collection<MitabFeature> features(int column):
{
  Collection<MitabFeature> features;
  MitabFeature var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
       var = feature(column)
       {features = new ArrayList<MitabFeature>(); if (var != null) {features.add(var);}}

       (<FIELD_SEPARATOR> var = feature(column) {if (var != null) {features.add(var);}})*
       {return features;}
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, column, e);
       error_skipToNext(enumSet);
       return Collections.EMPTY_LIST;
    }
}

Collection<MitabStoichiometry> stoichiometryList(int column):
{
  Collection<MitabStoichiometry> stc;
  MitabStoichiometry var;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    var = stoichiometry(column)
    {stc = new ArrayList<MitabStoichiometry>(); if (var != null) {stc.add(var);}}

    (<FIELD_SEPARATOR> var = stoichiometry(column) {if (var != null) {stc.add(var);}})*
    {return stc;}
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, column, e);
     error_skipToNext(enumSet);
     return Collections.EMPTY_LIST;
  }
}

MitabStoichiometry stoichiometry(int columnNumber):
{
  long min;
  long max = 0;
  java.lang.String minString;
  java.lang.String maxString = null;
  int beginLine;
  int beginColumn;
  MitabStoichiometry stc;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //float
    minString = safeStoichiometry()
    {
        min = Long.parseLong(minString);
        beginLine = token.beginLine;
        beginColumn = token.beginColumn;
      }
      [ "-" maxString = safeStoichiometry()
      {
            max = Long.parseLong(maxString);
      }
      ]
      {
         if (maxString != null){
            stc = new MitabStoichiometry(min, max);
         }
         else{
            stc = new MitabStoichiometry(min);
         }
         stc.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
         return stc;
      }
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
        error_skipToNext(enumSet);
        return null;
   }
   catch(NumberFormatException e){
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
       error_skipToNext(enumSet);
       return null;
   }
}

MitabFeature feature(int columnNumber):
{
  java.lang.String type;
  Collection<Range> ranges;
  Range var;
  java.lang.String text;
  MitabFeature feature;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //type:range1,range2(text)
    type = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> var = range(columnNumber)
    {ranges = new ArrayList<Range>(); if (var != null) {ranges.add(var);}}
    (<RANGE_SEPARATOR> var = range(columnNumber) {if (var != null) {ranges.add(var);}})* [ <OPEN_PAREN> text = safeString() <CLOSE_PAREN> ]
    {
        feature = new MitabFeature(type);
        feature.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        feature.getRanges().addAll(ranges);

        return feature;
      }
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet);
      return null;
  }
}

MitabRange range(int columnNumber):
{
  Position start;
  Position end;
  java.lang.String startString;
  java.lang.String endString;
  MitabRange range;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.RANGE_SEPARATOR, TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{

    //x-x
    (startString = safePosition()
    { beginLine = token.beginLine; beginColumn = token.beginColumn;
      start = PositionUtils.createPositionFromString(startString);
    }
    "-" endString = safePosition()
    {
    end = PositionUtils.createPositionFromString(endString);
     })
     { range = new MitabRange(start, end);
        range.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       return range;}
  }
  catch (ParseException e){
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet);
      return null;
    }
   catch(IllegalRangeException e){
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
       error_skipToNext(enumSet);
       return null;
   }
}

boolean negative():
{
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
  //false or true
    <NEGATIVE>
    {
        return Boolean.parseBoolean(token.image.trim());
      }
  }
  catch (ParseException e){
    processSyntaxError(token.beginLine, token.beginColumn, 16, e);
     error_skipToNext(enumSet);
     return false;
  }
}

MitabChecksum checksum(int columnNumber):
{
  java.lang.String method;
  java.lang.String value;
  MitabChecksum checksum;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //method:value
    method = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> value = safeString()
    {
        checksum = new MitabChecksum(method, value);
        checksum.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        return checksum;
      }
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
       error_skipToNext(enumSet);
        return null;
    }
}

MitabDate date(int columnNumber):
{
  java.lang.String date;
  MitabDate mitabDate;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //yyyy/mm/dd
    date = safeString()
    { mitabDate = new MitabDate(date);
        mitabDate.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, columnNumber));
        return mitabDate;
     }
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
     error_skipToNext(enumSet);
      return null;
  }
  catch (java.text.ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
     error_skipToNext(enumSet);
     return null;
  }
}

MitabParameter parameter() :
{
  java.lang.String type;
  java.lang.String value;
  java.lang.String unit = null;
  MitabParameter param;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //type:value(unit)
    type = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> value = safeString() [ <OPEN_PAREN> unit = safeString() <CLOSE_PAREN> ]
    {param = new MitabParameter(type, value, unit);
     param.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 30));
     return param;
     }
  }
  catch (ParseException e){
      processSyntaxError(token.beginLine, token.beginColumn, 30, e);
       error_skipToNext(enumSet);
       return null;
   }
   catch (IllegalParameterException e){
      processSyntaxError(token.beginLine, token.beginColumn, 30, e);
      error_skipToNext(enumSet);
      return null;
    }
}

MitabAnnotation annotation(int columnNumber):
{
  java.lang.String topic;
  java.lang.String value = null;
  MitabAnnotation annot;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //topic:value
    topic = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} [ <COLON> value = safeString() ]
    { annot = new MitabAnnotation(topic, value);
      annot.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
      return annot;}
  }
  catch (ParseException e){
         processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
         error_skipToNext(enumSet);
         return null;
      }
}

MitabXref xref(int columnNumber):
{
  java.lang.String db;
  java.lang.String id;
  java.lang.String text = null;
  MitabXref ref;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    //db:id(qualifier)
    db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> id = safeString() [ <OPEN_PAREN> text = safeString() <CLOSE_PAREN> ]
    { ref = new MitabXref(db, id, text);
      ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
      return ref;}
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
       error_skipToNext(enumSet);
       return null;
    }
}

MitabCvTerm expansion():
{
  java.lang.String db = null;
  java.lang.String id = null;
  java.lang.String name = null;
  MitabCvTerm cv;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
  //db:id(name) or just name for backward compatibility
    db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> id = safeString() [ <OPEN_PAREN> name = safeString() <CLOSE_PAREN> ]
    { if (name == null){cv = new MitabCvTerm(MitabUtils.UNKNOWN_DATABASE, null, db, id);
           cv.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 16));
           if (getParserListener() != null) {getParserListener().onMissingCvTermName(cv, cv, "The complex expansion method does not have a name.");}}
      else if (id == null) {cv = new MitabCvTerm(name);
            cv.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 16));
            if (getParserListener() != null) {getParserListener().onMissingExpansionId(cv);}}
      else {cv = new MitabCvTerm(name, null, db, id); cv.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 16));}
      return cv;}
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, 16, e);
     error_skipToNext(enumSet);
     return null;
  }
}

MitabConfidence confidence():
{
 java.lang.String type;
 java.lang.String value;
 java.lang.String text = null;
  MitabConfidence conf;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
    type = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> value = safeString() [ <OPEN_PAREN> text = safeString() <CLOSE_PAREN> ]
    { if (text == null){conf = new MitabConfidence(type, value, null); conf.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 15));}
      else {conf = new MitabConfidence(type, value, text); conf.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 15));
             if (getParserListener() != null) {getParserListener().onTextFoundInConfidence(conf);}}
      return conf;}
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, 15, e);
     error_skipToNext(enumSet);
     return null;
  }
}

MitabSource source():
{
  java.lang.String db;
  java.lang.String id;
  java.lang.String name = null;
  MitabSource s;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try {
     //db:id(name)
       db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> id = safeString() [ <OPEN_PAREN> name = safeString() <CLOSE_PAREN> ]
       { if (name == null){s = new MitabSource(MitabUtils.UNKNOWN_DATABASE, null, db, id); s.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 13));
            if (getParserListener() != null) {getParserListener().onMissingCvTermName(s, s, "The interaction source does not have a name.");}}
         else {s = new MitabSource(name, null, db, id); s.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 13));}
         return s;}
  }
  catch (ParseException e){
        processSyntaxError(token.beginLine, token.beginColumn, 13, e);
        error_skipToNext(enumSet);
        return null;
  }
}

MitabOrganism organism(int columnNumber):
{
  java.lang.String id;
  java.lang.String name = null;
  MitabOrganism organism;
  int beginLine;
  int beginColumn;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try {
  //taxid:id(name)
    <TAXID> <COLON> id = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} [ <OPEN_PAREN> name = safeString() <CLOSE_PAREN> ]
    {
       organism = new MitabOrganism(Integer.parseInt(id), name);
       organism.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       return organism;
     }
  }
  catch (ParseException e){
           processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
           error_skipToNext(enumSet);
           return null;
  }
  catch (NumberFormatException e){
           processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
           error_skipToNext(enumSet);
           return null;
  }
}

MitabAuthor author():
{
 MitabAuthor auth;
 java.lang.String first=null;
 java.lang.String date = null;
 int beginLine;
 int beginColumn;
 EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
     (( <PUB_DATE> {date = token.image.trim(); beginLine = token.beginLine; beginColumn = token.beginColumn;} [ first = safeAuthor() ])
     | ( first = safeAuthor() {beginLine = token.beginLine; beginColumn = token.beginColumn;} [ <OPEN_PAREN> <PUB_DATE> {date = token.image.trim();} <CLOSE_PAREN> ]))
     { beginLine = token.beginLine; beginColumn = token.beginColumn;
       if (date == null){auth = new MitabAuthor(first);}
       else{ auth = new MitabAuthor(first, date);}
       auth.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, 8));
       return auth;
      }
  }
  catch (ParseException e){
       processSyntaxError(token.beginLine, token.beginColumn, 8, e);
       error_skipToNext(enumSet);
       return null;
  }
}

MitabCvTerm cvTerm(int column):
{
  java.lang.String db;
  java.lang.String id = null;
  java.lang.String name = null;
  int beginLine;
  int beginColumn;
  MitabCvTerm cv;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  //db:id(name)
  try{
    db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> id = safeString() [ <OPEN_PAREN> name = safeString() <CLOSE_PAREN> ]
    { if (name == null){cv = new MitabCvTerm(MitabUtils.UNKNOWN_DATABASE, null, db, id); cv.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, column));
          if (getParserListener() != null){getParserListener().onMissingCvTermName(cv, cv, "The term at the column " + column + " does not have a name.");}}
      else {cv = new MitabCvTerm(name, null, db, id); cv.setSourceLocator(new MitabSourceLocator(token.beginLine, token.beginColumn, column));}
      return cv;}
  }
  catch (ParseException e){
     processSyntaxError(token.beginLine, token.beginColumn, column, e);
     error_skipToNext(enumSet);
     return null;
  }
}

MitabAlias alias(int columnNumber):
{
  java.lang.String db;
  java.lang.String name;
  java.lang.String type = null;
  int beginLine;
  int beginColumn;
  MitabAlias alias;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  //db:name(type)
  try{
      db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> name = safeString() [ <OPEN_PAREN> type = safeString() <CLOSE_PAREN> ]
      { alias = new MitabAlias(db, name, type);
        alias.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
        return alias;}
  }
  catch(ParseException e){
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet);
      return null;
  }
}

MitabXref id(CvTerm qualifier, boolean recognizeImexPrimary, int columnNumber):
{
  java.lang.String db;
  java.lang.String id;
  java.lang.String text = null;
  int beginLine;
  int beginColumn;
  MitabXref ref;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  try{
  //db:id(qualifier)
    db = safeString() {beginLine = token.beginLine; beginColumn = token.beginColumn;} <COLON> id = safeString() [ <OPEN_PAREN> text = safeString() <CLOSE_PAREN> ]
    { if (recognizeImexPrimary && Xref.IMEX.equalsIgnoreCase(db.trim())){
         if (text == null){ref = new MitabXref(db, id, CvTermUtils.createImexPrimaryQualifier()); ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));}
         else if (qualifier != null) {ref = new MitabXref(db, id, text);
         ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
         if (getParserListener() != null) {getParserListener().onTextFoundInIdentifier(ref);}}
         else {ref = new MitabXref(db, id, text); ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));}
       }
       else if (text == null) {
         ref = new MitabXref(db, id, qualifier);
         ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       }
       else if (qualifier != null) {
          ref = new MitabXref(db, id, text);
          ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
          if (getParserListener() != null) {getParserListener().onTextFoundInIdentifier(ref);}
       }
       else{
          ref = new MitabXref(db, id, text);
          ref.setSourceLocator(new MitabSourceLocator(beginLine, beginColumn, columnNumber));
       }
       return ref;}
   }
   catch(ParseException e){
      processSyntaxError(token.beginLine, token.beginColumn, columnNumber, e);
      error_skipToNext(enumSet);
      return null;
   }
}

java.lang.String safeString():
{
  java.lang.String result = null;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.COLON, TokenKind.OPEN_PAREN, TokenKind.CLOSE_PAREN, TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  ( <QUOTED_STRING> {result = token.image.substring(1,token.image.length() - 1).trim();}
   | result = anyStringBut(enumSet) )
  {return result;}
}

java.lang.String safeAuthor():
{
  java.lang.String result = null;
  EnumSet<TokenKind> enumSet = EnumSet.of(TokenKind.FIELD_SEPARATOR, TokenKind.OPEN_PAREN, TokenKind.CLOSE_PAREN,TokenKind.LINE_SEPARATOR, TokenKind.COLUMN_SEPARATOR);
}
{
  ( <QUOTED_STRING> {result = token.image.substring(1,token.image.length() - 1).trim();}
   | result = anyStringBut(enumSet)    )
  {return result;}
}

java.lang.String safePosition():
{java.lang.StringBuilder text = new StringBuilder();}
{
  (<POSITION> {text.append(token.image);}
   | (<LESSTHAN> {text.append(token.image);} (<DASH>)? {text.append(token.image);} <NUMBER> {text.append(token.image);})
   | (<GREATERTHAN> {text.append(token.image);} (<DASH>)? {text.append(token.image);} <NUMBER> {text.append(token.image);})
   | ( [<DASH> {text.append(token.image);}] <NUMBER> {text.append(token.image);}
        [".." {text.append(token.image);}
            [<DASH> {text.append(token.image);}] <NUMBER> {text.append(token.image);}])
   | <PUB_DATE> {text.append(token.image);})
  {return text.toString();}
}

java.lang.String safeStoichiometry():
{java.lang.String text;
 java.lang.String sign = "";}
{
  (["-" {sign = token.image;}](<STOICHIOMETRY> {text = token.image;}
   | <PUB_DATE> {text = token.image;}
   | <NUMBER> {text = token.image;}))
  {return sign+text;}
}

JAVACODE
java.lang.String anyStringBut(EnumSet<TokenKind> skipToTokens) {
  java.lang.StringBuilder result = new StringBuilder();

  Token t = getToken(1);
  // next token is 1
  while(t.kind != EOF && !skipToTokens.contains(TokenKind.getFromTokenKind(t.kind))){
      t = getNextToken();
      // check next token
      result.append(t.image);
      t = getToken(1);
  }
    // The above loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
    // "if"/"while".
    return result.length() > 0 ? result.toString() : null;
}

JAVACODE
void error_skipToNext(EnumSet<TokenKind> skipToTokens) {
  ParseException e = generateParseException();  // generate the exception object.
  System.out.println(e.toString());  // print the error message

  Token t = getToken(0);
  while(t.kind != EOF && !skipToTokens.contains(TokenKind.getFromTokenKind(t.kind))){
     // check next token
     t = getNextToken();
  }
    // The above loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
    // "if"/"while".
}
